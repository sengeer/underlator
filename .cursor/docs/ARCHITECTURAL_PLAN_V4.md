# Aрхитектурный план рефакторинга Underlator: Electron + React с интеграцией TypeScript и Ollama версии 3.0

## Общий контекст проекта

**Underlator** - десктопное приложение для конфиденциального перевода и анализа документов с использованием локальных LLM. Архитектура: React (frontend) + Electron (backend).

**Ключевые требования:**
- Работа с чувствительными данными (юристы, врачи, госслужащие)
- Только локальные LLM, никаких внешних HTTP запросов с данными пользователей
- Поддержка зоопарка моделей Ollama
- Полный отказ от @huggingface/transformers
- Прямая интеграция Ollama через HTTP API
- Сохранение Feature-Sliced Design на frontend
- Полная поддержка TypeScript в Electron backend

## Файловая архитектура

### **electron-app/src/** (Service Layer Architecture)
```
src/
├── main.ts                    # Electron main process (TypeScript)
├── preload.ts                 # Preload script (TypeScript)
├── model.js                   # Legacy: TranslationPipeline (для удаления)
├── worker.js                  # Legacy: Worker для transformers (для удаления)
├── services/                  # Service Layer - бизнес-логика и внешние сервисы
│   ├── index.ts               # Централизованный экспорт всех сервисов
│   ├── ollama-manager.ts      # Сервис управления Ollama через electron-ollama
│   ├── ollama-api.ts          # Сервис HTTP клиента для Ollama API
│   ├── model-catalog.ts       # Сервис получения каталога моделей
│   ├── splash-manager.ts      # НОВЫЙ: Сервис управления splash screen состоянием
│   └── model-downloader.js    # Legacy: Скачивание моделей (для удаления)
├── presentation/               # Presentation Layer - IPC handlers и UI логика
│   ├── ipc/
│   │   ├── ollama-handlers.ts # IPC обработчики для Ollama API
│   │   ├── catalog-handlers.ts # IPC обработчики для каталога моделей
│   │   └── splash-handlers.ts # НОВЫЙ: IPC обработчики для splash screen
│   └── splash/                # НОВЫЙ: Splash screen файлы
│       ├── index.html         # HTML для splash screen
│       ├── index.css          # Стили для splash screen
│       ├── script.js          # JavaScript для splash screen
│       └── assets/            # Статические ресурсы splash screen
│           └── logo.svg       # Логотип для splash screen (УЖЕ СОЗДАН)
├── types/                     # Domain Layer - типы и интерфейсы
│   ├── index.ts               # Централизованный экспорт всех типов
│   ├── ollama.types.ts        # Типы для Ollama API
│   ├── models.types.ts        # Типы для моделей
│   ├── generation.types.ts   # Типы для генерации
│   ├── catalog.types.ts       # Типы для каталога моделей
│   ├── parser.types.ts        # Типы для HTML парсера
│   ├── preload.types.ts       # Типы для preload скрипта
│   ├── splash.types.ts        # НОВЫЙ: Типы для splash screen
│   └── electron.d.ts          # Типы для Electron API
├── utils/                     # Infrastructure Layer - утилиты и вспомогательные функции
│   ├── ipc-handlers.ts        # Утилиты для обработки IPC сообщений
│   ├── error-handler.ts       # Утилиты для обработки ошибок
│   └── html-parser.ts         # Утилиты для HTML парсинга каталога моделей
└── constants/                 # Configuration Layer - константы и конфигурация
    ├── ollama.constants.ts    # Константы Ollama
    ├── catalog.constants.ts   # Константы каталога моделей
    └── splash.constants.ts    # НОВЫЙ: Константы splash screen
```

## Этап 1: Интеграция TypeScript в Electron проект

### 1.1 Установка TypeScript зависимостей и настройка tsconfig.json для Electron backend
**Цель:** Добавить полную поддержку TypeScript в Electron проект с правильной конфигурацией.

**Задачи:**
- Установить typescript, @types/node, @types/electron в package.json
- Создать tsconfig.json с настройками для Electron backend
- Настроить target ES2020, module commonjs, strict mode
- Добавить поддержку decorators и experimental features
- Настроить правильные пути для src/ и dist/

**Ожидаемый результат:** Полностью настроенный TypeScript для Electron backend с правильной конфигурацией компиляции.

### 1.2 Настройка webpack для транспиляции TypeScript в JavaScript
**Цель:** Настроить webpack для корректной работы с TypeScript файлами.

**Задачи:**
- Добавить ts-loader в webpack.config.js
- Настроить правила для .ts и .tsx файлов
- Обновить entry points для main.ts, preload.ts
- Настроить resolve.extensions для TypeScript
- Убедиться что webpack корректно транспилирует TypeScript

**Ожидаемый результат:** Webpack корректно транспилирует TypeScript файлы в JavaScript для Electron.

### 1.3 Миграция существующих JavaScript файлов на TypeScript
**Цель:** Переписать основные файлы Electron на TypeScript с правильной типизацией.

**Задачи:**
- Переименовать main.js в main.ts и добавить типизацию
- Переименовать preload.js в preload.ts и добавить типизацию
- Добавить типы для Electron API и IPC
- Создать интерфейсы для основных структур данных
- Убедиться что все импорты и экспорты корректно типизированы

**Ожидаемый результат:** Основные файлы Electron полностью переписаны на TypeScript с правильной типизацией.

## Этап 2: Создание инфраструктуры для работы с Ollama

### 2.1 Установка electron-ollama и создание OllamaManager для управления Ollama в Electron Main Process
**Цель:** Создать простую систему управления Ollama через electron-ollama библиотеку.

**Задачи:**
- Установить electron-ollama в package.json
- Создать src/services/ollama-manager.ts для управления Ollama
- Реализовать методы initialize(), startOllama(), stopOllama(), isOllamaRunning()
- Настроить автоматическую установку Ollama при первом запуске
- Добавить обработку ошибок и fallback логику

**Ожидаемый результат:** Простая система управления Ollama, которая автоматически устанавливает и запускает Ollama при старте Electron.

### 2.2 Создание HTTP клиента для работы с Ollama API
**Цель:** Создать простой и надежный HTTP клиент для взаимодействия с Ollama API.

**Задачи:**
- Создать src/services/ollama-api.ts для HTTP вызовов к Ollama
- Реализовать методы generate(), installModel(), removeModel(), listModels()
- Добавить поддержку streaming ответов для генерации
- Реализовать простую обработку ошибок и retry логику
- Добавить поддержку AbortController для отмены операций

**Ожидаемый результат:** Надежный HTTP клиент для работы с Ollama API, готовый для использования через IPC.

### 2.3 Создание типов и интерфейсов для Ollama API
**Цель:** Определить четкие типы для всех операций с Ollama API и исправить возникшие TypeScript ошибки.

**Задачи:**
- Испрвить TypeScript ошибки у файлов в electron-app/src/
- Обновить electron-app/src/types/ollama.types.ts с интерфейсами для API
- Создать electron-app/src/types/models.types.ts с типами для моделей
- Создать electron-app/src/types/generation.types.ts с типами для генерации
- Добавить типы для streaming ответов и прогресса
- Создать типы для ошибок и статусов

**Ожидаемый результат:** Полный набор типов для работы с Ollama API, обеспечивающий типобезопасность и отсутствие TypeScript ошибок по проекту.

## Этап 3: Создание IPC системы для взаимодействия с Ollama

### 3.1 Модификация main.ts для запуска Ollama и создания IPC handlers
**Цель:** Создать простую систему IPC для прямого взаимодействия с Ollama HTTP API.

**Задачи:**
- Модифицировать main.ts для запуска Ollama через OllamaManager
- Создать IPC handlers для ollama:generate, models:install, models:remove, models:list
- Интегрировать OllamaApi сервис с IPC handlers
- Добавить обработку ошибок и валидацию входных данных
- Настроить правильную последовательность запуска

**Ожидаемый результат:** Electron main process корректно запускает Ollama и предоставляет IPC API для взаимодействия с frontend.

### 3.2 Создание утилит для обработки IPC сообщений
**Цель:** Создать вспомогательные утилиты для работы с IPC и обработки ошибок.

**Задачи:**
- Создать src/utils/ipc-handlers.ts для централизованной обработки IPC
- Создать src/utils/error-handler.ts для обработки ошибок
- Добавить валидацию IPC сообщений
- Реализовать логирование IPC операций
- Создать утилиты для форматирования ответов

**Ожидаемый результат:** Надежная система обработки IPC сообщений с правильной обработкой ошибок.

### 3.3 Создание констант и конфигурации для Ollama
**Цель:** Централизовать все константы и настройки для Ollama.

**Задачи:**
- Создать src/constants/ollama.constants.ts
- Определить URL endpoints для Ollama API
- Добавить настройки таймаутов и retry попыток
- Создать константы для статусов и ошибок
- Добавить настройки для различных типов моделей

**Ожидаемый результат:** Централизованная конфигурация для всех операций с Ollama.

## Этап 4: Создание нового провайдера embedded-ollama на frontend

### 4.1 Создание структуры папок shared/providers/embedded-ollama/
**Цель:** Создать новый провайдер который заменит провайдер local.

**Задачи:**
- Создать папку shared/providers/embedded-ollama/
- Создать index.ts с экспортом embeddedOllamaProvider
- Создать types.ts с типами для нового провайдера
- Создать api.ts с методами для взаимодействия с Electron IPC
- Настроить правильную структуру файлов согласно FSD архитектуре

**Ожидаемый результат:** Полностью готовая структура нового провайдера с правильным размещением файлов.

### 4.2 Реализация embeddedOllamaProvider с единым методом generate
**Цель:** Создать провайдер который работает через Electron IPC и обрабатывает все типы задач.

**Задачи:**
- Реализовать embeddedOllamaProvider.generate() метод
- Добавить поддержку как строк, так и массивов строк
- Интегрировать с window.electron.ollama.generate() через IPC
- Реализовать обработку статусов (progress, message, complete, error)
- Добавить поддержку AbortController для отмены операций
- Реализовать правильную обработку контекстного перевода

**Ожидаемый результат:** Рабочий провайдер который заменяет функциональность local провайдера.

### 4.3 Обновление системы провайдеров
**Цель:** Интегрировать новый провайдер в существующую систему провайдеров.

**Задачи:**
- Обновить shared/providers/index.ts
- Добавить embedded-ollama в список провайдеров
- Обновить ProviderType для включения 'embedded-ollama'
- Обновить getModelUseProvider функцию
- Подготовить к удалению старых провайдеров

**Ожидаемый результат:** Система провайдеров работает с новым embedded-ollama провайдером.

## Этап 5: Создание системы получения каталога моделей Ollama

### 5.1 Создание сервиса для получения каталога моделей
**Цель:** Создать систему для получения полного списка доступных моделей Ollama.

**Задачи:**
- Создать src/services/model-catalog.ts для получения каталога
- Реализовать методы getAvailableModels(), getModelInfo(), searchModels()
- Интегрировать с Ollama Registry API для получения списка моделей
- Добавить кэширование каталога для оптимизации
- Реализовать фильтрацию и поиск по моделям

**Ожидаемый результат:** Система для получения полного каталога доступных моделей Ollama.

### 5.2 Создание типов для каталога моделей
**Цель:** Определить типы для работы с каталогом моделей.

**Задачи:**
- Создать src/types/catalog.types.ts
- Определить интерфейсы для ModelCatalog, CatalogModel, ModelMetadata
- Добавить типы для фильтрации и поиска
- Создать типы для статусов моделей (available, installed, downloading)
- Добавить типы для метаданных моделей (размер, описание, теги)

**Ожидаемый результат:** Полный набор типов для работы с каталогом моделей.

### 5.3 Создание IPC handlers для каталога моделей
**Цель:** Создать IPC API для получения каталога моделей.

**Задачи:**
- Добавить IPC handlers для catalog:get, catalog:search, catalog:get-model-info
- Интегрировать ModelCatalog сервис с IPC handlers
- Добавить поддержку фильтрации через IPC
- Реализовать кэширование на уровне IPC
- Добавить обработку ошибок и валидацию
- Добавить на стороне React front-end функции для тестирования новых IPC в файл react-app/src/widgets/settings/tests/ipc-tester.js и кнопки в react-app/src/widgets/settings/ui/index.tsx

**Ожидаемый результат:** IPC API для получения каталога моделей через frontend.

### 5.4 Улучшение HTML парсера для получения каталога всех квантизаций
**Цель:** Обновить HTML парсер для получения полного списка вариантов моделей которые можно установить в Ollama.

**Задачи:**
- Улучшить utils/html-parser.ts, чтобы он создавал каталог моделей со всеми варантами квантизаций
- Если требуется обновить типы types/parser.types.ts
- Следить что бы не сломалась логика catalog:get, catalog:get с forceRefresh, catalog:search с фильтрами и catalog:get-model-info

**Ожидаемый результат:** Улучшенная логика которая предоставляет полный каталог моделей, а не каталог стандартных моделей без квантизации.

## Этап 6: Рефакторинг SelectorPopup и создание универсальных UI компонентов

### 6.1 Создание компонента Search для поиска в списках
**Цель:** Создать переиспользуемый компонент поиска для использования в SelectorPopup и других списках.

**Задачи:**
- Создать shared/ui/search/index.tsx с базовой функциональностью поиска
- Реализовать поддержку debounce для оптимизации производительности
- Добавить поддержку placeholder и кастомных стилей
- Создать shared/ui/search/types.ts с интерфейсами для Search
- Добавить поддержку очистки поиска и горячих клавиш
- Реализовать поддержку иконки поиска (присутствует в react-app/src/shared/assets/icons)
- Придерживаться минималистичного собственного UI Kit основанного на четырёх корневых цветах: main, background, accent, foreground и использовании rem (можно подглядеть в другие .scss компонентов)

**Ожидаемый результат:** Переиспользуемый компонент Search готовый для интеграции в SelectorPopup.

### 6.2 Создание компонента SelectorOption с множественными состояниями
**Цель:** Создать универсальный компонент пункта списка который поддерживает простые и сложные состояния согласно SOLID принципам.

**Задачи:**
- Создать shared/ui/selector-option/index.tsx как основной компонент
- Реализовать паттерн Strategy для рендеринга разных режимов
- Создать shared/ui/selector-option/simple-mode.tsx для простых пунктов (TextButton)
- Создать shared/ui/selector-option/complex-mode.tsx для сложных пунктов
- Добавить shared/ui/selector-option/types.ts с интерфейсами для всех состояний
- Реализовать поддержку состояний: simple, loading, installed, available, error
- Добавить поддержку кастомных стилей и анимаций

**Ожидаемый результат:** Универсальный SelectorOption компонент с поддержкой всех необходимых состояний.

### 6.3 Интеграция ленивой загрузки в компонент Popup
**Цель:** Реализовать логику ленивой загрузки и интегрировать её в компонент Popup с помощью Intersection Observer API

**Задачи:**
- Создать react-app/src/shared/lib/hooks/use-intersection-observer/index.ts основной хук
- Создать react-app/src/shared/lib/hooks/use-intersection-observer/types.ts для типов
- Добавить комонент ленивой загрузки react-app/src/shared/ui/popup/lazy-list-item.tsx
- Добавить типы для ленивой загрузки в модуль react-app/src/shared/ui/popup/types.ts

**Ожидаемый результат:** Оптимизированный Popup с поддержкой ленивой загрузки.

### 6.4 Создание нового компонента PopupWithSearch для поддержки поиска в модальном окне
**Цель:** Создать новый компонент PopupWithSearch который расширяет базовый Popup по приницпу LSP, добавляя компонент Search в модальное окно.

**Задачи:**
- Создать react-app/src/shared/ui/popup-with-search/index.tsx
- Изменить Popup если того требует расширение по LSP
- Если требуется, добавить типы для нового расширенного компонента в react-app/src/shared/ui/popup-with-search/types.ts

**Ожидаемый результат:** Переиспользуемый независимый компонент PopupWithSearch готовый к дальнейшей интеграции с Electron API.

## Этап 7: Интеграция взаимодействия с Electron API в React приложение

### 7.1 Создание удобных функций для обращения к Electron API
**Цель:** Создать модуль react-app/src/widgets/settings/api/embedded-ollama-electron-api.ts который позволит: получать каталог моделей, выполнять простой поиск по названию, выполнять фильтрацию, сортировку моделей, загружать модель с прогрессом, удалять модель.

**Задачи:**
- Создать индексный файл react-app/src/widgets/settings/api/index.ts
- Создать react-app/src/widgets/settings/api/embedded-ollama-electron-api.ts для взаимодействия с Electron API
- Создать react-app/src/widgets/settings/api/types.ts для типов взаимодействия с Electron API
- Реализовать функцию для запросов получения каталога моделей для рендера списка SelectorOption на его основе в будующем
- Реализовать функцию для запросов поиска, фильтрации и сортировки моделей по названию под использование компонентом Search и models-slice в будующем
- Добавить функцию для запросов загрузки модели с возможностью отображения прогресса под интеграцию с компонентом SelectorOption и models-slice в будующем
- Создать функцию удаления модели под интеграцию с компонентом  SelectorOption в будующем

**Ожидаемый результат:** Подготовить модуль для использования Electron API, готовый к интеграции с логикой управления.

### 7.2 Реализация Redux slice для управления моделями в Settings
**Цель:** Создать централизованное управление состоянием моделей в контексте Settings виджета.

**Задачи:**
- Создать widgets/settings/model/manage-embedded-ollama-slice.ts с initialState для каталога и процесса установки
- Добавить reducers для setCatalog, setInstallationProgress, setSearchQuery
- Реализовать async thunks который взаимодействует с модулем api/index.ts
- Добавить обработку состояний loading, error, success для каждой операции
- Реализовать поддержку фильтрации и сортировки моделей
- Добавить поддержку кэширования и оптимизации запросов

**Ожидаемый результат:** Redux slice для частичного управления моделями в контексте Settings виджета.

### 7.3 Создание компонента который связывает запросы Electron API с подготовленными React компонентами
**Цель:** Создать компонент ManageModels с логикой связанной с интеграцией, должен возвращать PopupWithSearch который будет импортироваться в Settings.

**Задачи:**
- Создать react-app/src/widgets/settings/ui/manage-embedded-ollama.tsx компонент который соединяет в себе всю логику взаимодейтвия с провайдером Embedded Ollama
- Добавить интеграцию с provider-settings-slice как в Settings в котором указывается выбранная модель
- Создать react-app/src/widgets/settings/ui/types.ts для типов
- Интегрировать компонент в Settings для провайдера Embedded Ollama

**Ожидаемый результат:** UI с основными действиями для управления моделями Embedded Ollama внутри Settings виджета с оптимизированным рендером и расширяемой архитектурой.

## Этап 8: Создание системы Splash Screen для молниеносного отображения прогресса инициализации Ollama

### 8.1 Создание  Single Window Splash Screen UI внутри основного окна приложения
**Цель:** Создать splash screen который отображается ВНУТРИ основного окна приложения при запуске Electron и показывает прогресс инициализации Ollama с минималистичным UI. Сначала показывать splash screen, потом основное приложение в том же окне (Single Window Splash подход).

Требования к UI (СТРОГО):
- МИНИМАЛИСТИЧНЫЙ UI: только логотип и текст состояния
- Логотип: использовать УЖЕ СОЗДАННЫЙ файл `/presentation/splash/assets/images/logo.svg`
- Анимация логотипа: плавная зацикленная пульсация логотипа
- Отступы: 1rem от краев
- Текст состояния: `font-family: "Roboto Mono"; font-size: 1rem; font-weight: 600;`
- Расположение: логотип по центру, текст состояния внизу
- Цвета: использовать корневые цвета из React приложения (задний фон #282a36, текст #f8f8f2)

**Задачи:**
- Подготовить конфигурацию electron-app/webpack.config.js для правильной сборки файлов HTML, CSS, изображений, шрифтов и т.д
- Подключить индексный файл заведомо ДОБАВЛЕННЫХ шрифтов electron-app/src/presentation/splash/assets/fonts/index.css
- Модифицировать main.ts для создания основного окна БЕЗ загрузки React приложения
- Создать presentation/splash/index.html с минималистичным UI (только логотип и текст)
- Создать presentation/splash/index.css с анимацией логотипа и стилями текста
- Создать presentation/splash/script.js для обработки обновлений статуса
- Реализовать логику показа splash screen в основном окне
- Реализовать переход от splash screen к основному React приложению в том же окне

**Ожидаемый результат:** Основное окно приложения сначала показывает минималистичный splash screen с анимированным логотипом и текстом состояния, затем переключается на основное React приложение.

### 8.2 Реализация системы передачи состояния инициализации Ollama в Splash Screen
**Цель:** Создать систему для передачи детального прогресса инициализации Ollama в splash screen с обновлением статуса в реальном времени.

**Задачи:**
- Модифицировать OllamaManager для передачи событий инициализации (initialize, startOllama, healthCheck)
- Создать services/splash-manager.ts для управления состоянием splash screen согласно Service Layer Architecture
- Создать presentation/ipc/splash-handlers.ts для IPC обработчиков splash screen
- Создать types/splash.types.ts для типов splash screen
- Создать constants/splash.constants.ts для констант splash screen
- Добавить IPC события для передачи статуса: splash:update-status, splash:set-progress, splash:complete
- Обновить main.ts для использования SplashManager для управления состоянием splash screen
- Добавить обработку ошибок с отображением в splash screen
- Реализовать автоматическое скрытие splash screen и показ основного приложения

**Ожидаемый результат:** Полностью работоспособная система splash screen с детальным отображением прогресса инициализации Ollama и плавным переходом к основному приложению в том же окне.

## Этап 9: Удаление старых провайдеров и зависимостей

### 9.1 Удаление старых провайдеров
**Цель:** Полностью очистить проект от старых провайдеров и их кода.

**Задачи:**
- Удалить shared/providers/local/ папку полностью
- Удалить shared/apis/ollama/ папку
- Обновить shared/providers/index.ts
- Удалить ProviderType 'Electron IPC' и 'Ollama'
- Обновить все импорты и ссылки

**Ожидаемый результат:** Проект полностью очищен от старых провайдеров.

### 9.2 Удаление @huggingface/transformers
**Цель:** Убрать все упоминания и использование @huggingface/transformers.

**Задачи:**
- Удалить @huggingface/transformers из package.json
- Удалить src/model.js файл полностью
- Удалить src/worker.js файл полностью
- Удалить src/services/model-downloader.js файл полностью
- Обновить main.ts, убрав все ссылки на старые сервисы
- Удалить все импорты и использование старых модулей

**Ожидаемый результат:** Electron backend полностью очищен от @huggingface/transformers.

### 9.3 Очистка зависимостей
**Цель:** Оптимизировать зависимости и упростить процесс сборки.

**Задачи:**
- Удалить неиспользуемые зависимости из package.json
- Обновить скрипты сборки для работы с TypeScript
- Проверить и обновить все devDependencies
- Убедиться что сборка работает корректно

**Ожидаемый результат:** Оптимизированный package.json с правильными зависимостями для TypeScript.

## Этап 10: Тестирование и финальная оптимизация

### 10.1 Комплексное тестирование системы
**Цель:** Убедиться что все компоненты системы работают корректно вместе.

**Задачи:**
- Протестировать запуск Ollama через electron-ollama в Electron
- Проверить корректность IPC коммуникации между frontend и backend
- Протестировать работу нового embedded-ollama провайдера
- Проверить корректность контекстного перевода
- Протестировать установку и удаление моделей через Ollama API
- Проверить работу с различными типами задач
- Протестировать UI компоненты для управления моделями
- Протестировать получение каталога моделей
- Проверить работу обновленного SelectorPopup

**Ожидаемый результат:** Полностью рабочая система с корректной интеграцией всех компонентов.

### 10.2 Финальная оптимизация и настройка
**Цель:** Оптимизировать систему и убедиться в соблюдении требований безопасности.

**Задачи:**
- Проверить отсутствие внешних HTTP запросов с данными пользователей
- Оптимизировать производительность генерации через Ollama HTTP API
- Настроить правильные параметры для различных типов моделей
- Проверить корректность работы с большими документами
- Оптимизировать UI для лучшего пользовательского опыта
- Провести финальное тестирование всех сценариев использования
- Убедиться в правильной работе TypeScript и IPC системы
- Оптимизировать кэширование каталога моделей

**Ожидаемый результат:** Оптимизированная, безопасная и производительная система с полной поддержкой TypeScript.

## Ключевые принципы архитектуры

### **Service Layer Architecture (Electron Backend)**
✅ **Service Layer Pattern** - четкое разделение на слои: Services, Presentation, Domain, Infrastructure, Configuration
✅ **Single Responsibility** - каждый сервис отвечает за одну область функциональности
✅ **Dependency Injection** - сервисы получают зависимости через конструктор или фабричные методы
✅ **Interface Segregation** - четкие интерфейсы между слоями
✅ **Centralized Exports** - единые точки входа для импорта (services/index.ts, types/index.ts)

### **Feature-Sliced Design (React Frontend)**
✅ **FSD compliance** - строгое соблюдение Feature-Sliced Design без нарушения границ слоев
✅ **Правильная структура** - компоненты управления моделями в Settings виджете согласно FSD

### **Общие принципы**
✅ **TypeScript поддержка** - полная типизация Electron backend и React frontend
✅ **Прямая интеграция** - React → IPC → Electron → HTTP → Ollama
✅ **Простота** - понятная архитектура без лишних слоев
✅ **Производительность** - меньше hop'ов, быстрее работа
✅ **Молниеносный запуск** - splash screen появляется мгновенно при старте
✅ **Красивый UI** - современные компоненты для управления моделями
✅ **SOLID принципы** - модульная архитектура компонентов
✅ **Безопасность** - полная конфиденциальность данных
✅ **Каталог моделей** - полный список доступных моделей Ollama
✅ **Виртуализация** - оптимизированный рендер для больших списков
✅ **Переиспользование** - универсальные UI компоненты (SelectorOption, Search, OptimizedList)
✅ **Композиция** - гибкие композитные компоненты для разных сценариев
✅ **Плавные переходы** - seamless переход от splash screen к основному приложению

## Ожидаемый результат

После завершения всех этапов у вас будет:

### **Electron Backend (Service Layer Architecture)**
- **Service Layer Pattern** - четко структурированный backend с разделением на слои
- **TypeScript backend** - полностью типизированный Electron backend
- **Модульные сервисы** - OllamaManager, OllamaApi, ModelCatalogService, SplashManager
- **Централизованные экспорты** - единые точки входа для всех сервисов и типов
- **Четкие интерфейсы** - типизированные контракты между слоями

### **React Frontend (Feature-Sliced Design)**
- **FSD compliance** - правильная структура без нарушения границ слоев
- **Интегрированное управление моделями** - все компоненты управления моделями в Settings виджете
- **Переиспользуемые компоненты** - SelectorOption, Search, OptimizedList для других проектов
- **Гибкая композиция** - готовые композитные компоненты для разных сценариев

### **Общие возможности**
- **Молниеносный запуск** - splash screen появляется мгновенно с красивой анимацией
- **Высокая производительность** - нативные Ollama модели через HTTP API
- **Красивый UI** - современные компоненты для управления моделями
- **Каталог моделей** - полный список доступных моделей Ollama
- **Масштабируемость** - легко добавлять новые модели и возможности
- **Безопасность** - полная конфиденциальность данных
- **User-friendly** - автоматическая установка и красивое управление моделями
- **Оптимизированный рендер** - виртуализированные оптимизированные списки для тысяч моделей
- **Плавные переходы** - seamless переход от splash screen к основному приложению

Каждый этап можно делегировать отдельному агенту, который получит детальные инструкции и сможет выполнить задачу качественно.