# Архитектурный план реализации RAG системы (Retrieval-Augmented Generation)

## Общий контекст проекта

**Ключевые требования для RAG системы:**
- Работа с чувствительными данными (юристы, врачи, госслужащие)
- Только локальные LLM и векторные хранилища, никаких внешних HTTP запросов с данными пользователей
- Локальное хранение документов и векторных эмбеддингов в файлах проекта
- Контекстное взаимодействие с LLM моделями на основе загруженных документов
- Интеграция с существующей системой useModel и чатом
- Поддержка различных форматов документов (PDF)
- Два режима работы: постоянное хранилище для чатов и In-Memory для PDF Viewer

## Анализ текущей архитектуры

### Существующие компоненты для интеграции

**React Frontend (FSD Architecture):**
- `useModel` хук - единая точка взаимодействия с LLM с поддержкой режимов chat, translation, instruction, contextualTranslation
- `feature-provider` - определяет способы обработки запросов через различные провайдеры
- Redux store с слайсами для управления состоянием элементов и провайдеров
- UI компоненты: Popup, BaseButton, SelectorOption, MarkdownRenderer, FileUpload
- Система стилей с CSS переменными и SCSS
- Компоненты чата: Chat, ChatMessages, ChatSidebar, MessageBubble

**Electron Backend (Service Layer Architecture):**
- IPC система с `IpcHandler` для унифицированной обработки запросов
- `OllamaApi` для HTTP взаимодействия с LLM моделями
- `preload.ts` для безопасного API с поддержкой чатов и моделей
- Система сервисов: ollama-manager, model-catalog, ChatFileSystemService
- FileSystemService с поддержкой типов файлов: chat, document, settings, log
- PDF Viewer с обработкой PDF документов через pdf.js

## Архитектурный план реализации

## Этап 1: Создание инфраструктуры RAG системы

### 1.1 Установка и настройка зависимостей для RAG
**Цель:** Установить необходимые библиотеки для обработки документов, создания эмбеддингов и векторного поиска.

**Задачи:**
- Установить LlamaIndex как основной фреймворк для RAG pipeline с поддержкой документов и векторного поиска
- Установить ChromaDB для локального векторного хранилища с высокой производительностью
- Установить pdf-parse для извлечения текста из PDF документов с поддержкой различных кодировок
- Установить соответствующие TypeScript типы для всех библиотек
- Настроить конфигурацию сборки для корректной работы с нативными модулями
- Обеспечить совместимость с существующей системой сборки Electron
- Добавить необходимые dev-зависимости для разработки и тестирования

**Ожидаемый результат:** Полностью настроенная среда разработки с всеми необходимыми зависимостями для RAG системы.

### 1.2 Создание типов данных для RAG системы
**Цель:** Создать полный набор типов для работы с документами, чанками, эмбеддингами и векторным поиском.

**Задачи:**
- Создать файл типов `electron-app/src/types/rag.ts` с интерфейсами для RAG системы
- Определить интерфейс `DocumentChunk` с уникальным идентификатором, содержимым текста, метаданными включающими источник, номер страницы, индекс чанка, идентификатор чата, опциональный массив эмбеддингов
- Определить интерфейс `RAGQuery` с текстом запроса, идентификатором чата, количеством возвращаемых результатов, порогом схожести
- Определить интерфейс `RAGResponse` с ответом модели, массивом источников, уровнем уверенности
- Определить интерфейс `DocumentProcessingResult` с флагом успеха, массивом чанков, опциональной ошибкой
- Определить интерфейс `ProcessingProgress` для отслеживания прогресса обработки документов
- Определить интерфейс `VectorCollection` для управления коллекциями в векторном хранилище
- Добавить типы для операций с векторным хранилищем включая создание, добавление, поиск, удаление коллекций
- Интегрировать типы с существующей системой типов проекта и обеспечить типобезопасность

**Ожидаемый результат:** Полный набор типизированных интерфейсов для RAG системы, обеспечивающий типобезопасность на всех уровнях приложения.

### 1.3 Создание сервиса векторного хранилища
**Цель:** Создать сервис для управления векторными эмбеддингами с использованием ChromaDB.

**Задачи:**
- Создать файл `electron-app/src/services/vector-store.ts` с классом `VectorStoreService`
- Реализовать инициализацию ChromaDB клиента с локальным хранилищем в папке проекта
- Реализовать метод `createCollection` для создания коллекции для конкретного чата с уникальным именем
- Реализовать метод `addChunks` для добавления чанков документов в коллекцию с метаданными
- Реализовать метод `query` для поиска релевантных чанков по текстовому запросу с настройкой параметров
- Реализовать метод `deleteCollection` для удаления коллекции при удалении чата
- Реализовать метод `getCollectionStats` для получения статистики по коллекции
- Реализовать метод `cleanup` для очистки ресурсов при завершении работы приложения
- Добавить обработку ошибок векторного хранилища с детальным логированием
- Обеспечить атомарность операций с векторным хранилищем
- Реализовать кэширование часто используемых коллекций для оптимизации производительности

**Ожидаемый результат:** Полнофункциональный сервис векторного хранилища с поддержкой всех операций CRUD и оптимизацией производительности.

### 1.4 Создание сервиса обработки документов
**Цель:** Создать сервис для извлечения текста из различных форматов документов и разбиения на чанки.

**Задачи:**
- Создать файл `electron-app/src/services/document-processor.ts` с классом `DocumentProcessorService`
- Реализовать метод `processPDF` для извлечения текста из PDF файлов с сохранением структуры страниц
- Реализовать метод `processDOCX` для извлечения текста из Word документов с сохранением форматирования
- Реализовать метод `processTXT` для обработки текстовых файлов с различными кодировками
- Реализовать метод `splitIntoChunks` для разбиения текста на контекстно-значимые фрагменты с перекрытием
- Реализовать метод `extractMetadata` для извлечения метаданных документов включая название, автора, дату создания
- Реализовать метод `validateDocument` для проверки корректности документа и его размера
- Добавить поддержку различных кодировок текста включая UTF-8, Windows-1251, ISO-8859-1
- Реализовать обработку ошибок чтения документов с информативными сообщениями
- Обеспечить поддержку больших документов с потоковой обработкой
- Добавить прогресс-индикаторы для длительных операций обработки документов

**Ожидаемый результат:** Универсальный сервис обработки документов с поддержкой различных форматов и оптимизацией производительности.

## Этап 2: Интеграция с Ollama для эмбеддингов

### 2.1 Создание сервиса эмбеддингов
**Цель:** Создать сервис для генерации векторных эмбеддингов через Ollama с использованием локальных моделей.

**Задачи:**
- Создать файл `electron-app/src/services/embedding-service.ts` с классом `EmbeddingService`
- Реализовать инициализацию сервиса с подключением к существующему `OllamaApi`
- Реализовать метод `generateEmbedding` для генерации эмбеддинга одного текста через Ollama
- Реализовать метод `generateEmbeddings` для батчевой генерации эмбеддингов с оптимизацией производительности
- Реализовать метод `validateEmbeddingModel` для проверки доступности модели эмбеддингов
- Реализовать метод `getEmbeddingDimensions` для получения размерности векторов эмбеддингов
- Добавить поддержку модели `nomic-embed-text` как основной для эмбеддингов
- Реализовать fallback на альтернативные модели эмбеддингов при недоступности основной
- Добавить кэширование эмбеддингов для избежания повторных вычислений
- Реализовать обработку ошибок генерации эмбеддингов с retry логикой
- Обеспечить совместимость с существующей системой управления моделями Ollama

**Ожидаемый результат:** Полнофункциональный сервис эмбеддингов с интеграцией в существующую систему Ollama.

### 2.2 Расширение OllamaApi для поддержки эмбеддингов
**Цель:** Расширить существующий OllamaApi для поддержки генерации эмбеддингов.

**Задачи:**
- Модифицировать файл `electron-app/src/services/ollama-api.ts` для добавления поддержки эмбеддингов
- Реализовать метод `generateEmbedding` для генерации эмбеддинга через Ollama API
- Реализовать метод `generateEmbeddings` для батчевой генерации эмбеддингов
- Добавить валидацию параметров запроса для эмбеддингов
- Реализовать обработку ошибок специфичных для эмбеддингов
- Добавить поддержку различных моделей эмбеддингов с автоматическим определением размерности
- Обеспечить совместимость с существующими методами генерации текста
- Добавить логирование операций с эмбеддингами для отладки
- Реализовать оптимизацию запросов для уменьшения нагрузки на Ollama
- Обеспечить корректную обработку streaming ответов для эмбеддингов

**Ожидаемый результат:** Расширенный OllamaApi с полной поддержкой генерации эмбеддингов.

### 2.3 Создание утилит для работы с эмбеддингами
**Цель:** Создать утилиты для обработки и оптимизации эмбеддингов.

**Задачи:**
- Создать файл `electron-app/src/utils/embedding-utils.ts` с утилитами для работы с эмбеддингами
- Реализовать функцию `normalizeEmbedding` для нормализации векторов эмбеддингов
- Реализовать функцию `calculateSimilarity` для вычисления схожести между эмбеддингами
- Реализовать функцию `batchEmbeddings` для оптимизации батчевой обработки эмбеддингов
- Реализовать функцию `validateEmbedding` для проверки корректности эмбеддинга
- Реализовать функцию `compressEmbedding` для сжатия эмбеддингов при необходимости
- Добавить утилиты для работы с различными метриками схожести включая косинусное сходство
- Реализовать функции для сериализации и десериализации эмбеддингов
- Добавить утилиты для оптимизации памяти при работе с большими объемами эмбеддингов
- Обеспечить совместимость с различными форматами эмбеддингов

**Ожидаемый результат:** Набор утилит для эффективной работы с эмбеддингами и оптимизации производительности.

## Этап 3: Создание IPC API для RAG системы

### 3.1 Создание IPC обработчиков для RAG
**Цель:** Создать IPC API для взаимодействия frontend с RAG системой через безопасный preload скрипт.

**Задачи:**
- Создать файл `electron-app/src/presentation/ipc/rag-handlers.ts` с обработчиками для RAG операций
- Использовать существующий `IpcHandler.createHandlerWrapper` для унифицированной обработки ошибок и логирования
- Реализовать обработчик `rag:process-document` для обработки загруженных документов и создания эмбеддингов
- Реализовать обработчик `rag:query-documents` для поиска релевантных документов по запросу
- Реализовать обработчик `rag:delete-collection` для удаления коллекции документов чата
- Реализовать обработчик `rag:get-collection-stats` для получения статистики по коллекции
- Реализовать обработчик `rag:list-collections` для получения списка всех коллекций
- Добавить валидацию входных данных для всех обработчиков с детальными сообщениями об ошибках
- Реализовать обработку ошибок файловой системы и векторного хранилища
- Добавить детальное логирование всех операций RAG для отладки и мониторинга
- Обеспечить атомарность операций с документами и векторным хранилищем

**Ожидаемый результат:** Полнофункциональный IPC API для RAG системы с унифицированной обработкой ошибок и логированием.

### 3.2 Обновление preload скрипта для RAG
**Цель:** Добавить API для работы с RAG системой в безопасный preload скрипт.

**Задачи:**
- Модифицировать файл `electron-app/src/preload.ts` для добавления RAG API
- Добавить объект `rag` в `contextBridge.exposeInMainWorld('electron')` с методами для обработки документов
- Реализовать метод `processDocument` для обработки загруженных документов с прогресс-индикатором
- Реализовать метод `queryDocuments` для поиска релевантных документов по текстовому запросу
- Реализовать метод `deleteDocumentCollection` для удаления коллекции документов чата
- Реализовать метод `getCollectionStats` для получения статистики по коллекции документов
- Реализовать метод `onProcessingProgress` для подписки на события прогресса обработки документов
- Использовать `ipcRenderer.invoke` для асинхронного взаимодействия с main процессом
- Включить правильную типизацию параметров и возвращаемых значений для всех методов
- Обеспечить безопасность через contextBridge и валидацию входных данных
- Интегрироваться с существующей структурой API и следовать паттернам именования

**Ожидаемый результат:** Безопасный API для работы с RAG системой через preload скрипт с полной типизацией.

### 3.3 Обновление типов preload для RAG
**Цель:** Добавить типы для RAG API в систему типов preload скрипта.

**Задачи:**
- Обновить файл типов `electron-app/src/types/preload.ts` для добавления типов RAG в интерфейс `ElectronAPI`
- Добавить объект `rag` с типизированными методами для всех операций RAG
- Определить интерфейсы для параметров всех методов RAG API с полной типизацией
- Определить интерфейсы для возвращаемых значений всех методов RAG API
- Добавить типы для событий прогресса обработки документов
- Обеспечить совместимость с существующими типами preload API
- Добавить поддержку всех операций CRUD для документов и коллекций
- Интегрироваться с существующей системой типов проекта
- Обеспечить типобезопасность при использовании RAG API в renderer процессе
- Добавить типы для обработки ошибок и исключений RAG системы

**Ожидаемый результат:** Полная типизация RAG API в preload скрипте с обеспечением типобезопасности.

## Этап 4: Расширение системы useModel для поддержки RAG

### 4.1 Расширение типов useModel для RAG
**Цель:** Добавить поддержку режима RAG в существующую систему типов useModel.

**Задачи:**
- Модифицировать файл `react-app/src/shared/lib/hooks/use-model/types/use-model.ts` для добавления поддержки RAG
- Создать интерфейс `RAGUseModelParams`, расширяющий `UseModelParams` с дополнительными полями для идентификатора чата, параметров поиска документов, настроек релевантности
- Создать интерфейс `RAGModelResponse`, расширяющий `ModelResponse` с полями для источников документов, уровня уверенности, метаданных поиска
- Добавить новый тип `typeUse` со значением 'rag' для идентификации режима RAG
- Обновить существующие типы для поддержки контекстных запросов с документами
- Добавить типы для параметров векторного поиска включая topK, similarityThreshold
- Интегрировать новые типы с существующей системой типов проекта
- Обеспечить совместимость с существующими режимами работы useModel
- Добавить типы для обработки ошибок RAG системы

**Ожидаемый результат:** Расширенная система типов useModel с полной поддержкой режима RAG и векторного поиска.

### 4.2 Создание утилит для работы с RAG контекстом
**Цель:** Создать утилиты для построения контекстных промптов на основе найденных документов.

**Задачи:**
- Создать файл `react-app/src/shared/lib/hooks/use-model/utils/rag-context.ts` для утилит работы с RAG контекстом
- Реализовать утилиту `buildRAGPrompt` для построения промпта с учетом найденных релевантных документов
- Реализовать утилиту `formatDocumentSources` для форматирования источников документов в читаемый вид
- Реализовать утилиту `extractRelevantChunks` для извлечения наиболее релевантных фрагментов документов
- Реализовать утилиту `calculateRelevanceScore` для вычисления релевантности найденных документов
- Реализовать утилиту `mergeDocumentContext` для объединения контекста из нескольких документов
- Реализовать утилиту `validateRAGResponse` для валидации ответа RAG системы
- Добавить конфигурацию для различных стратегий построения RAG промптов
- Реализовать кэширование обработанного RAG контекста для оптимизации производительности
- Добавить валидацию RAG контекста и обработку ошибок

**Ожидаемый результат:** Набор утилит для эффективного построения RAG контекста с оптимизацией релевантности и производительности.

### 4.3 Расширение feature-provider для обработки RAG
**Цель:** Интегрировать RAG функциональность в feature-provider и реализовать обработку RAG запросов.

**Задачи:**
- Модифицировать файл `react-app/src/shared/lib/hooks/use-model/feature-provider.ts` для добавления обработки режима RAG
- Создать функцию `handleRAGQuery` для обработки запросов в режиме RAG с использованием векторного поиска
- Реализовать поиск релевантных документов через IPC API с настройкой параметров поиска
- Интегрировать утилиты `buildRAGPrompt`, `formatDocumentSources`, `extractRelevantChunks` в обработку RAG
- Реализовать логику построения контекстного промпта на основе найденных документов
- Использовать существующую логику streaming для получения ответов от модели с RAG контекстом
- Реализовать обработку источников документов в ответе модели
- Интегрировать `handleRAGQuery` в существующий `featureProvider.generate` с проверкой `typeUse === 'rag'`
- Обеспечить совместимость с существующими режимами работы без нарушения текущей функциональности
- Добавить обработку ошибок RAG системы и fallback логику при проблемах с векторным поиском

**Ожидаемый результат:** Расширенный feature-provider с поддержкой режима RAG и интеллектуального векторного поиска.

## Этап 5: Интеграция с чатом

### 5.1 Добавление кнопки загрузки файлов в чат
**Цель:** Добавить возможность загрузки документов в чат через нативное диалоговое окно Electron.

**Задачи:**
- Модифицировать файл `react-app/src/widgets/chat/ui/chat-sidebar.tsx` для добавления кнопки загрузки файлов
- Реализовать обработчик `handleFileUpload` для открытия нативного диалогового окна выбора файлов
- Настроить фильтры файлов для поддержки PDF, DOCX, TXT форматов с соответствующими расширениями
- Реализовать обработку выбранного файла с передачей пути в RAG систему через IPC API
- Добавить валидацию размера и типа загружаемого файла с информативными сообщениями об ошибках
- Реализовать прогресс-индикатор загрузки и обработки документа
- Добавить поддержку drag-and-drop загрузки файлов в область чата
- Интегрироваться с существующей системой уведомлений для отображения статуса загрузки
- Обеспечить корректную обработку ошибок загрузки и обработки файлов
- Добавить поддержку множественной загрузки файлов с батчевой обработкой

**Ожидаемый результат:** Полнофункциональная система загрузки документов в чат с поддержкой различных форматов и обработкой ошибок.

### 5.2 Создание компонента отображения источников документов
**Цель:** Создать компонент для отображения источников документов в ответах RAG системы.

**Задачи:**
- Создать файл `react-app/src/widgets/chat/ui/document-sources.tsx` для отображения источников документов
- Реализовать отображение списка источников с информацией о документе, странице, релевантности
- Добавить возможность клика по источнику для перехода к соответствующему фрагменту документа
- Реализовать подсветку релевантных фрагментов текста в источниках
- Добавить поддержку различных типов источников включая PDF страницы, DOCX разделы, TXT абзацы
- Реализовать компактное и развернутое отображение источников с возможностью переключения
- Добавить индикаторы релевантности источников с цветовой кодировкой
- Интегрироваться с существующими UI компонентами проекта для консистентности дизайна
- Обеспечить адаптивность компонента для различных размеров экрана
- Добавить анимации появления и скрытия источников для улучшения пользовательского опыта

**Ожидаемый результат:** Информативный компонент отображения источников документов с интерактивностью и адаптивным дизайном.

### 5.3 Интеграция RAG с существующими компонентами чата
**Цель:** Интегрировать RAG функциональность в существующие компоненты чата без нарушения текущей функциональности.

**Задачи:**
- Модифицировать файл `react-app/src/widgets/chat/ui/chat.tsx` для интеграции RAG режима
- Добавить переключатель между обычным чатом и RAG режимом в интерфейсе чата
- Реализовать автоматическое определение режима работы на основе наличия документов в чате
- Интегрировать компонент отображения источников документов в область сообщений
- Добавить индикатор активного RAG режима в заголовке чата
- Реализовать логику переключения между режимами с сохранением контекста
- Обеспечить корректную работу useModel в RAG режиме с передачей правильных параметров
- Добавить поддержку горячих клавиш для быстрого переключения режимов
- Интегрироваться с существующей системой управления состоянием элементов
- Обеспечить совместимость с существующими функциями чата включая копирование, редактирование сообщений

**Ожидаемый результат:** Полностью интегрированная RAG функциональность в существующий интерфейс чата с сохранением всех текущих возможностей.

## Этап 6: Интеграция с PDF Viewer

### 6.1 Реализация In-Memory Vector Store для PDF Viewer
**Цель:** Реализовать режим In-Memory векторного хранилища для PDF Viewer с обработкой документов в оперативной памяти.

**Задачи:**
- Модифицировать файл `react-app/src/widgets/pdf-viewer/ui/pdf-viewer.tsx` для добавления RAG режима
- Реализовать состояние `ragMode` для переключения между обычным режимом и RAG режимом
- Реализовать состояние `documentChunks` для хранения обработанных фрагментов PDF в памяти
- Создать обработчик `processPDFForRAG` для обработки загруженного PDF и создания эмбеддингов
- Реализовать автоматическую обработку PDF при включении RAG режима
- Добавить ограничения на размер обрабатываемых PDF для предотвращения проблем с памятью
- Реализовать очистку памяти при переключении режимов или закрытии PDF
- Добавить прогресс-индикатор обработки PDF для RAG режима
- Обеспечить корректную обработку ошибок при обработке PDF для RAG
- Реализовать кэширование обработанных PDF для избежания повторной обработки

**Ожидаемый результат:** Полнофункциональный In-Memory режим RAG для PDF Viewer с оптимизацией использования памяти.

### 6.2 Обновление UI PDF Viewer для RAG режима
**Цель:** Обновить интерфейс PDF Viewer для поддержки RAG режима с сохранением существующей функциональности.

**Задачи:**
- Добавить переключатель RAG режима в существующую панель переключения режимов PDF Viewer
- Реализовать визуальную индикацию активного RAG режима с соответствующими иконками
- Добавить информацию о количестве обработанных фрагментов документа в RAG режиме
- Реализовать отображение источников найденных фрагментов при использовании RAG поиска
- Добавить поддержку выделения релевантных фрагментов в PDF при RAG запросах
- Обеспечить корректную работу существующих функций PDF Viewer в RAG режиме
- Добавить настройки RAG режима включая размер чанков, порог релевантности
- Реализовать сохранение настроек RAG режима между сессиями
- Обеспечить адаптивность интерфейса RAG режима для различных размеров экрана
- Добавить анимации переключения между режимами для улучшения пользовательского опыта

**Ожидаемый результат:** Обновленный интерфейс PDF Viewer с полной поддержкой RAG режима и сохранением существующей функциональности.

### 6.3 Интеграция RAG поиска с PDF Viewer
**Цель:** Интегрировать RAG поиск с существующими функциями PDF Viewer для контекстного взаимодействия с документами.

**Задачи:**
- Реализовать использование RAG системы для поиска релевантных фрагментов в загруженном PDF
- Интегрировать результаты RAG поиска с существующей системой выделения текста в PDF
- Реализовать автоматическое выделение найденных релевантных фрагментов в PDF документе
- Добавить возможность клика по найденным фрагментам для перехода к соответствующей странице
- Реализовать отображение контекста найденных фрагментов с возможностью расширения
- Обеспечить корректную работу RAG поиска с существующими функциями перевода и инструкций
- Добавить поддержку комбинированного поиска по тексту и RAG векторному поиску
- Реализовать сохранение результатов RAG поиска для последующего использования
- Обеспечить производительность RAG поиска в In-Memory режиме
- Добавить обработку ошибок RAG поиска с информативными сообщениями

**Ожидаемый результат:** Полностью интегрированная RAG система поиска с PDF Viewer с улучшенным пользовательским опытом.

## Этап 7: Управление жизненным циклом RAG системы

### 7.1 Интеграция с ChatFileSystemService
**Цель:** Интегрировать RAG систему с существующей системой управления файлами чатов.

**Задачи:**
- Модифицировать файл `electron-app/src/services/filesystem-chat.ts` для интеграции с RAG системой
- Реализовать метод `deleteChatWithRAG` для удаления чата и связанных векторных данных
- Реализовать метод `getChatRAGStats` для получения статистики по документам чата
- Реализовать метод `backupChatRAGData` для создания резервных копий векторных данных чата
- Реализовать метод `restoreChatRAGData` для восстановления векторных данных из резервной копии
- Добавить автоматическое создание векторных коллекций при создании нового чата
- Реализовать синхронизацию между файловой системой чатов и векторным хранилищем
- Добавить валидацию целостности данных между чатами и векторными коллекциями
- Реализовать очистку неиспользуемых векторных коллекций при удалении чатов
- Обеспечить атомарность операций удаления чатов с векторными данными

**Ожидаемый результат:** Полностью интегрированная система управления жизненным циклом RAG данных с существующей файловой системой чатов.

### 7.2 Очистка ресурсов и управление памятью
**Цель:** Реализовать корректную очистку ресурсов RAG системы при завершении работы приложения.

**Задачи:**
- Модифицировать файл `electron-app/src/main.ts` для добавления очистки RAG ресурсов
- Реализовать метод `cleanupRAGResources` для очистки всех ресурсов RAG системы
- Добавить очистку векторных коллекций и временных файлов при завершении работы
- Реализовать сохранение состояния RAG системы для корректного восстановления при перезапуске
- Добавить мониторинг использования памяти RAG системой с логированием
- Реализовать автоматическую очистку неиспользуемых векторных коллекций
- Добавить обработку ошибок при очистке ресурсов с детальным логированием
- Обеспечить корректное завершение всех активных операций RAG перед очисткой
- Реализовать сохранение прогресса обработки документов для возможности возобновления
- Добавить валидацию целостности данных после очистки ресурсов

**Ожидаемый результат:** Надежная система управления ресурсами RAG с корректной очисткой и мониторингом производительности.

### 7.3 Мониторинг и логирование RAG системы
**Цель:** Реализовать комплексную систему мониторинга и логирования для RAG системы.

**Задачи:**
- Создать файл `electron-app/src/utils/rag-monitoring.ts` для мониторинга RAG системы
- Реализовать сбор метрик производительности включая время обработки документов, генерации эмбеддингов, векторного поиска
- Реализовать мониторинг использования памяти и дискового пространства векторным хранилищем
- Добавить логирование всех операций RAG системы с различными уровнями детализации
- Реализовать сбор статистики по использованию RAG функций включая количество запросов, популярные документы
- Добавить мониторинг ошибок RAG системы с автоматическим уведомлением о критических проблемах
- Реализовать создание отчетов по производительности RAG системы
- Добавить мониторинг качества векторного поиска с метриками релевантности
- Реализовать систему алертов при превышении пороговых значений производительности
- Обеспечить интеграцию мониторинга RAG с существующей системой логирования приложения

**Ожидаемый результат:** Комплексная система мониторинга и логирования RAG системы с детальными метриками и алертами.

## План поэтапной реализации

### Этап 1: Подготовка инфраструктуры (2-3 дня)
Создание базовых типов и сервисов RAG системы, установка и настройка зависимостей включая LlamaIndex и ChromaDB, создание сервиса векторного хранилища с поддержкой коллекций, реализация сервиса обработки документов с поддержкой PDF, DOCX, TXT форматов, создание сервиса эмбеддингов с интеграцией в OllamaApi.

### Этап 2: Backend интеграция (3-4 дня)
Создание IPC обработчиков для RAG системы с использованием существующего IpcHandler, обновление preload скрипта для безопасного доступа к RAG API, расширение feature-provider для поддержки режима RAG с векторным поиском, создание утилит для работы с RAG контекстом и эмбеддингами, тестирование IPC коммуникации и обработки ошибок.

### Этап 3: Frontend интеграция (3-4 дня)
Добавление кнопки загрузки файлов в чат с поддержкой нативного диалогового окна, создание компонента отображения источников документов, интеграция RAG режима в существующие компоненты чата, реализация In-Memory режима для PDF Viewer, обновление UI PDF Viewer для поддержки RAG функциональности.

### Этап 4: Интеграция и оптимизация (2-3 дня)
Полная интеграция всех компонентов RAG системы с тестированием функциональности, оптимизация производительности векторного поиска и обработки документов, реализация управления жизненным циклом RAG данных, создание системы мониторинга и логирования, обработка edge cases и ошибок.

### Этап 5: Тестирование и полировка (2-3 дня)
Комплексное тестирование RAG системы на различных сценариях использования, тестирование производительности с большими документами и множественными запросами, оптимизация использования памяти и дискового пространства, финальная полировка UI/UX, создание документации для разработчиков и пользователей.

## Технические детали

### Архитектура векторного хранилища

**Локальное хранение с ChromaDB:**
Система векторного хранилища построена на ChromaDB для обеспечения высокой производительности локальных операций. Каждый чат имеет отдельную коллекцию в векторном хранилище для изоляции данных. Коллекции автоматически создаются при загрузке первого документа в чат и удаляются при удалении чата.

**In-Memory режим для PDF Viewer:**
Для PDF Viewer реализован специальный In-Memory режим векторного хранилища, который хранит эмбеддинги в оперативной памяти для быстрого доступа. Этот режим оптимизирован для работы с одним документом и автоматически очищается при переключении режимов или закрытии документа.

**Оптимизация производительности:**
- Кэширование часто используемых эмбеддингов для избежания повторных вычислений
- Батчевая обработка документов для оптимизации использования ресурсов
- Индексация векторных коллекций для ускорения поиска
- Сжатие эмбеддингов при необходимости для экономии места

### Обработка документов

**Поддержка форматов:**
Система поддерживает обработку PDF документов через pdf-parse с сохранением структуры страниц, DOCX файлов через mammoth с сохранением форматирования, и текстовых файлов с поддержкой различных кодировок включая UTF-8, Windows-1251, ISO-8859-1.

**Разбиение на чанки:**
Документы автоматически разбиваются на контекстно-значимые фрагменты размером 512 символов с перекрытием 50 символов для сохранения контекста. Размер чанков настраивается в зависимости от типа документа и требований к производительности.

**Метаданные документов:**
Каждый чанк содержит метаданные включающие источник документа, номер страницы, индекс чанка, идентификатор чата, временные метки создания и обновления. Метаданные используются для фильтрации и ранжирования результатов поиска.

### Интеграция с Ollama

**Модели эмбеддингов:**
Основная модель эмбеддингов - nomic-embed-text, оптимизированная для работы с Ollama и обеспечивающая высокое качество эмбеддингов для многоязычных текстов. Система поддерживает fallback на альтернативные модели при недоступности основной.

**Генерация эмбеддингов:**
Эмбеддинги генерируются через существующий OllamaApi с поддержкой батчевой обработки для оптимизации производительности. Система автоматически определяет размерность векторов эмбеддингов и валидирует их корректность.

**Оптимизация запросов:**
Реализована оптимизация запросов к Ollama для уменьшения нагрузки на сервер включая кэширование эмбеддингов, батчевую обработку, retry логику при ошибках, мониторинг производительности генерации эмбеддингов.

## Возможные проблемы и решения

### Проблема: Высокое потребление памяти при обработке больших документов
**Решение:** Реализовать потоковую обработку документов с загрузкой по частям, ограничение размера обрабатываемых документов с предупреждениями пользователя, автоматическая очистка памяти при переключении режимов, оптимизация размера чанков в зависимости от доступной памяти, мониторинг использования памяти с автоматическими алертами.

### Проблема: Медленная генерация эмбеддингов через Ollama
**Решение:** Реализовать батчевую обработку эмбеддингов для оптимизации запросов к Ollama, кэширование эмбеддингов для избежания повторных вычислений, параллельная обработка множественных документов, оптимизация параметров запросов к Ollama, fallback на альтернативные модели эмбеддингов при проблемах с производительностью.

### Проблема: Низкое качество векторного поиска
**Решение:** Реализовать настройку параметров поиска включая размер чанков, порог релевантности, количество возвращаемых результатов, экспериментирование с различными моделями эмбеддингов, добавление метаданных для улучшения фильтрации, реализация гибридного поиска сочетающего векторный и текстовый поиск.

### Проблема: Проблемы с синхронизацией между файловой системой и векторным хранилищем
**Решение:** Реализовать транзакционные операции с откатом изменений при ошибках, регулярная проверка целостности данных между чатами и векторными коллекциями, автоматическое восстановление данных при обнаружении несоответствий, создание резервных копий векторных данных, мониторинг синхронизации с детальным логированием.

### Проблема: Совместимость с различными моделями Ollama
**Решение:** Реализовать автоматическое определение поддерживаемых моделей эмбеддингов, динамическая настройка параметров в зависимости от модели, fallback механизмы при недоступности предпочитаемых моделей, валидация совместимости моделей при инициализации, уведомления пользователя о рекомендуемых моделях.

### Проблема: Производительность векторного поиска при большом количестве документов
**Решение:** Реализовать индексацию векторных коллекций для ускорения поиска, пагинация результатов поиска с ленивой загрузкой, кэширование часто используемых запросов, оптимизация алгоритмов поиска с использованием различных метрик схожести, мониторинг производительности поиска с автоматической оптимизацией.

## Заключение

Данный план обеспечивает поэтапную реализацию RAG системы с учетом существующей архитектуры проекта Underlator. Архитектура построена на существующих компонентах и принципах проекта, что обеспечивает совместимость и поддерживаемость кода.

Ключевые преимущества реализации:
- Использование существующей инфраструктуры без дублирования функциональности
- Соответствие принципам FSD и Service Layer Architecture
- Безопасность и конфиденциальность данных через локальное хранение
- Расширяемость и возможность добавления новых функций в будущем
- Интеграция с существующей системой управления моделями и чатами
- Поддержка различных форматов документов с оптимизированной обработкой
- Два режима работы: постоянное хранилище для чатов и In-Memory для PDF Viewer
- Полная типизация для обеспечения надежности кода
- Универсальная система векторного поиска с поддержкой различных моделей эмбеддингов
- Интеллектуальная обработка документов с сохранением контекста
- Оптимизированная производительность с кэшированием и мониторингом
