# Архитектурный план реализации чата с контекстом и локальным хранением в Underlator

## Общий контекст проекта

**Ключевые требования для чата:**
- Работа с чувствительными данными (юристы, врачи, госслужащие)
- Только локальные LLM, никаких внешних HTTP запросов с данными пользователей
- Локальное хранение чатов в файлах проекта
- Контекстное взаимодействие с LLM моделями
- Собственный UI в стиле проекта (monkeytype-like design)
- Интеграция с существующей системой useModel

## Анализ текущей архитектуры

### Существующие компоненты для интеграции

**React Frontend (FSD Architecture):**
- `useModel` хук - единая точка взаимодействия с LLM
- `feature-provider` - определяет способы обработки запросов
- Redux store с слайсами для управления состоянием
- UI компоненты: Popup, BaseButton, SelectorOption, MarkdownRenderer
- Система стилей с CSS переменными и SCSS

**Electron Backend (Service Layer Architecture):**
- IPC система с `IpcHandler` для унифицированной обработки
- `OllamaApi` для HTTP взаимодействия с LLM
- `preload.ts` для безопасного API
- Система сервисов: ollama-manager, model-catalog

## Архитектурный план реализации

## Этап 1: Создание IPC API для файловой системы

### 1.1 Создание FileSystemService для управления файлами чатов
**Цель:** Создать сервис для безопасного управления файлами чатов в Electron main процессе.

**Задачи:**
- Создать сервис `FileSystemService` в папке `electron-app/src/services/`
- Реализовать автоматическое создание папки `chats` в `userData` при инициализации
- Обеспечить атомарные операции записи для предотвращения потери данных при сбоях
- Реализовать валидацию JSON структуры файлов чатов
- Поддержать автоматическое резервное копирование при обновлении файлов
- Обрабатывать ошибки файловой системы с детальным логированием
- Ограничить размер файлов чатов для предотвращения проблем с производительностью
- Реализовать механизм блокировки файлов для предотвращения конфликтов при одновременном доступе

**Ожидаемый результат:** Полнофункциональный сервис для безопасного управления файлами чатов с поддержкой атомарных операций и резервного копирования.

### 1.2 Определение типов данных для чатов
**Цель:** Создать полный набор типов для работы с чатами и сообщениями.

**Задачи:**
- Создать файл типов `electron-app/src/types/chat.ts` с интерфейсами для чатов
- Определить интерфейс `ChatMessage` с уникальным идентификатором, ролью отправителя, содержимым в формате Markdown, временной меткой, опциональной информацией о модели и контексте
- Определить интерфейс `ChatData` с уникальным идентификатором чата, заголовком, массивом сообщений, временными метками создания и обновления, информацией о модели по умолчанию, опциональным контекстом
- Определить интерфейс `ChatFile` с метаданными для отображения в списке чатов без загрузки полного содержимого
- Добавить типы для операций CRUD с чатами
- Интегрировать типы с существующей системой типов проекта

**Ожидаемый результат:** Полный набор типизированных интерфейсов для работы с чатами, обеспечивающий типобезопасность на всех уровнях приложения.

### 1.3 Настройка IPC обработчиков для чатов
**Цель:** Создать IPC API для взаимодействия frontend с файловой системой чатов.

**Задачи:**
- Создать файл `electron-app/src/presentation/ipc/chat-handlers.ts` с обработчиками для операций CRUD
- Использовать существующий `IpcHandler.createHandlerWrapper` для унифицированной обработки ошибок и логирования
- Реализовать обработчик создания нового чата с генерацией уникального ID и временных меток
- Реализовать обработчик чтения чата по ID с проверкой существования файла
- Реализовать обработчик обновления чата с атомарной записью и резервным копированием
- Реализовать обработчик удаления чата с подтверждением и возможностью восстановления
- Реализовать обработчик получения списка всех чатов с метаданными для быстрого отображения
- Добавить валидацию входных данных, обработку ошибок файловой системы, детальное логирование операций

**Ожидаемый результат:** Полнофункциональный IPC API для работы с чатами через безопасный preload скрипт.

### 1.4 Обновление preload скрипта
**Цель:** Добавить API для работы с чатами в безопасный preload скрипт.

**Задачи:**
- Модифицировать файл `electron-app/src/preload.ts` для добавления API чатов
- Добавить объект `chat` в `contextBridge.exposeInMainWorld('electron')` с методами для создания, чтения, обновления, удаления и получения списка чатов
- Использовать `ipcRenderer.invoke` для асинхронного взаимодействия с main процессом
- Включить правильную типизацию параметров и возвращаемых значений
- Обеспечить безопасность через contextBridge
- Интегрироваться с существующей структурой API
- Следовать существующему паттерну именования и структуры
- Обновить файл типов `electron-app/src/types/preload.ts` для добавления типов чатов в интерфейс `ElectronAPI`
- Добавить объект `chat` с типизированными методами
- Обеспечить совместимость с существующими типами
- Добавить поддержку всех операций CRUD для чатов
- Интегрироваться с существующей системой типов
- Обеспечить типобезопасность при использовании API в renderer процессе

**Ожидаемый результат:** Безопасный API для работы с чатами через preload скрипт.

## Этап 2: Расширение системы useModel для поддержки чата

### 2.1 Расширение типов useModel для поддержки чата
**Цель:** Добавить поддержку режима чата в существующую систему типов useModel.

**Задачи:**
- Модифицировать файл `react-app/src/shared/lib/hooks/use-model/types/use-model.ts` для добавления поддержки чата
- Создать интерфейс `ChatUseModelParams`, расширяющий `UseModelParams` с дополнительными полями для идентификатора чата, контекста чата, флага сохранения истории сообщений
- Создать интерфейс `ChatModelResponse`, расширяющий `ModelResponse` с полями для идентификатора чата и сообщения
- Добавить новый тип `typeUse` со значением 'chat' для идентификации режима чата
- Обновить существующие типы для поддержки контекстных сообщений и истории чата
- Интегрировать новые типы с существующей системой типов проекта

**Ожидаемый результат:** Расширенная система типов useModel с полной поддержкой режима чата и контекстных сообщений.

### 2.2 Расширение feature-provider для обработки чата
**Цель:** Адаптировать feature-provider для обработки запросов в режиме чата с контекстом.

**Задачи:**
- Модифицировать файл `react-app/src/shared/lib/hooks/use-model/feature-provider.ts` для добавления обработки режима чата
- Создать функцию `handleChat` для обработки запросов в режиме чата с загрузкой контекста предыдущих сообщений через IPC API
- Реализовать построение промпта с учетом истории чата и контекста
- Использовать существующую логику streaming для получения ответов от модели
- Реализовать сохранение ответа в контексте чата
- Интегрировать `handleChat` в существующий `featureProvider.generate` с проверкой `typeUse === 'chat'`
- Обеспечить совместимость с существующими режимами работы (translation, instruction) без нарушения текущей функциональности

**Ожидаемый результат:** Расширенный feature-provider с поддержкой режима чата, сохраняющий совместимость с существующими режимами работы.

### 2.3 Создание утилит для работы с контекстом чата
**Цель:** Создать вспомогательные утилиты для работы с контекстом и историей чата.

**Задачи:**
- Создать утилиты для построения промптов чата с учетом контекста предыдущих сообщений
- Реализовать ограничение длины контекста для предотвращения превышения лимитов модели
- Создать функции форматирования сообщений в соответствии с требованиями конкретной модели
- Реализовать обработку специальных команд в чате (например, очистка контекста, смена модели)
- Создать механизм кэширования контекста для оптимизации производительности при частых запросах к одному чату
- Добавить валидацию контекста и обработку ошибок при работе с историей чата

**Ожидаемый результат:** Набор утилит для эффективной работы с контекстом чата и оптимизации производительности.

## Этап 3: Создание Redux слайса для управления чатами

### 3.1 Создание ChatSlice для управления состоянием чатов
**Цель:** Создать Redux slice для централизованного управления состоянием чатов.

**Задачи:**
- Создать Redux slice `react-app/src/shared/models/chat-slice/chat-slice.ts` для управления состоянием чатов
- Определить интерфейс `ChatState` с полями для списка чатов, активного чата, состояния загрузки, ошибок, флага генерации ответа
- Создать `initialState` с пустыми значениями по умолчанию
- Реализовать синхронные reducers для установки активного чата, добавления сообщений в активный чат, обновления существующих сообщений, управления состоянием генерации ответа
- Использовать `createSlice` для автоматической генерации action creators и reducers
- Добавить типизацию для всех действий и состояния

**Ожидаемый результат:** Полнофункциональный Redux slice для управления состоянием чатов с типизированными действиями и состоянием.

### 3.2 Создание async thunks для операций с чатами
**Цель:** Реализовать асинхронные операции с чатами через IPC API.

**Задачи:**
- Создать async thunks для асинхронных операций с чатами через IPC API
- Реализовать `loadChats` для загрузки списка всех чатов с метаданными
- Реализовать `createChat` для создания нового чата с автоматической генерацией ID и временных меток
- Реализовать `loadChat` для загрузки полного содержимого конкретного чата
- Реализовать `updateChat` для обновления чата с атомарной записью
- Реализовать `deleteChat` для удаления чата с подтверждением
- Обеспечить обработку состояний pending, fulfilled, rejected с соответствующими обновлениями состояния
- Добавить обработку ошибок и валидацию для каждого thunk

**Ожидаемый результат:** Набор async thunks для всех операций CRUD с чатами, интегрированных с IPC API.

### 3.3 Интеграция ChatSlice с основным store
**Цель:** Интегрировать ChatSlice в основную систему управления состоянием приложения.

**Задачи:**
- Добавить chat reducer в основной store `react-app/src/app/models/store.ts`
- Создать селекторы для доступа к состоянию чатов с использованием `createSelector` для оптимизации производительности
- Реализовать селекторы для получения списка чатов, активного чата, состояния загрузки, ошибок
- Добавить типизацию для RootState и AppDispatch с учетом нового chat slice
- Интегрировать с существующей системой middleware и devtools
- Обеспечить совместимость с существующими слайсами

**Ожидаемый результат:** Полностью интегрированный ChatSlice в основную систему управления состоянием с оптимизированными селекторами.

## Этап 4: Создание UI компонентов чата

### 4.1 Создание основного компонента Chat
**Цель:** Создать основной компонент для управления интерфейсом чата в соответствии с FSD архитектурой.

**Задачи:**
- Создать основной компонент `react-app/src/widgets/chat/ui/chat.tsx` для управления интерфейсом чата
- Интегрироваться с Redux store для получения состояния чатов
- Использовать хук `useModel` для взаимодействия с LLM
- Управлять состоянием ввода сообщений
- Автоматически прокручивать к последним сообщениям
- Обрабатывать отправку сообщений с валидацией
- Интегрироваться с системой переводов через `useLingui`
- Структурировать компонент с боковой панелью со списком чатов, заголовком с информацией о текущем чате, областью отображения сообщений, полем ввода сообщений

**Ожидаемый результат:** Полнофункциональный основной компонент чата, интегрированный с существующими системами проекта.

### 4.2 Создание компонента ChatMessages
**Цель:** Создать компонент для отображения сообщений чата с поддержкой Markdown и виртуализации.

**Задачи:**
- Создать компонент `react-app/src/widgets/chat/ui/chat-messages.tsx` для отображения сообщений чата
- Отображать список сообщений с поддержкой Markdown рендеринга
- Показывать индикатор генерации ответа с анимацией
- Автоматически прокручивать к новым сообщениям
- Поддерживать виртуализацию для больших чатов
- Отображать временные метки сообщений
- Поддерживать копирование сообщений
- Использовать существующий компонент `MarkdownRenderer` для отображения содержимого сообщений
- Добавить обработку ошибок и состояний загрузки

**Ожидаемый результат:** Оптимизированный компонент для отображения сообщений с поддержкой Markdown и виртуализации.

### 4.3 Создание компонента ChatInput
**Цель:** Создать компонент для ввода сообщений с поддержкой многострочного ввода и горячих клавиш.

**Задачи:**
- Создать компонент `react-app/src/widgets/chat/ui/chat-input.tsx` для ввода сообщений
- Поддерживать многострочный ввод с автоматическим изменением высоты
- Обрабатывать горячие клавиши (Enter для отправки, Shift+Enter для новой строки)
- Валидировать ввод с предотвращением отправки пустых сообщений
- Отображать состояние загрузки
- Интегрироваться с системой переводов для placeholder
- Использовать существующий компонент `BaseButton` для кнопки отправки
- Добавить поддержку автодополнения и истории ввода

**Ожидаемый результат:** Удобный компонент ввода сообщений с поддержкой всех необходимых функций.

### 4.4 Создание дополнительных компонентов чата
**Цель:** Создать вспомогательные компоненты для полноценного интерфейса чата.

**Задачи:**
- Создать компонент `ChatSidebar` для отображения списка чатов с возможностью создания новых, переключения между чатами, поиска по чатам, удаления чатов
- Создать компонент `ChatHeader` для отображения информации о текущем чате, управления настройками чата, остановки генерации ответа
- Создать компонент `MessageBubble` для отображения отдельных сообщений с поддержкой различных типов сообщений, действий с сообщениями (копирование, редактирование)
- Интегрировать все компоненты с существующими UI компонентами проекта (Popup, SelectorOption, BaseButton)
- Добавить поддержку адаптивности для мобильных устройств

**Ожидаемый результат:** Полный набор компонентов для создания полноценного интерфейса чата.

## Этап 5: Создание стилей чата

### 5.1 Создание основных стилей чата
**Цель:** Создать основные стили для компонента чата в соответствии с дизайн-системой проекта.

**Задачи:**
- Создать файл стилей `react-app/src/widgets/chat/styles/chat.scss` для основного компонента чата
- Использовать существующие CSS переменные проекта (--background, --foreground, --main, --accent)
- Реализовать адаптивную верстку для различных размеров экрана
- Обеспечить правильное позиционирование элементов
- Поддерживать анимации появления и скрытия чата
- Интегрироваться с существующей системой стилей
- Структурировать стили с классами для основного контейнера чата, боковой панели, основной области чата, адаптивных изменений для мобильных устройств

**Ожидаемый результат:** Основные стили чата, интегрированные с дизайн-системой проекта и поддерживающие адаптивность.

### 5.2 Создание стилей для сообщений чата
**Цель:** Создать стили для отображения сообщений с поддержкой Markdown и анимаций.

**Задачи:**
- Создать файл стилей `react-app/src/widgets/chat/styles/chat-messages.scss` для отображения сообщений
- Обеспечить правильное отображение сообщений пользователя и ассистента с различным оформлением
- Поддерживать автоматическую прокрутку к новым сообщениям
- Отображать индикатор генерации ответа с анимацией
- Обеспечить читаемость текста с правильными отступами и размерами шрифтов
- Поддерживать отображение временных меток
- Интегрироваться с компонентом MarkdownRenderer
- Реализовать анимацию печати для индикатора генерации ответа

**Ожидаемый результат:** Стили для сообщений с поддержкой Markdown, анимаций и оптимальной читаемости.

### 5.3 Создание стилей для ввода сообщений
**Цель:** Создать стили для поля ввода сообщений с поддержкой многострочного ввода.

**Задачи:**
- Создать файл стилей `react-app/src/widgets/chat/styles/chat-input.scss` для поля ввода сообщений
- Обеспечить правильное отображение многострочного поля ввода с автоматическим изменением высоты
- Поддерживать состояние загрузки с визуальными индикаторами
- Обеспечить правильное позиционирование кнопки отправки
- Поддерживать адаптивность для мобильных устройств
- Интегрироваться с существующими стилями BaseButton
- Реализовать плавные переходы и анимации для улучшения пользовательского опыта
- Добавить поддержку фокуса и состояний взаимодействия

**Ожидаемый результат:** Стили для поля ввода с поддержкой всех необходимых функций и состояний.

### 5.4 Создание стилей для дополнительных компонентов
**Цель:** Создать стили для вспомогательных компонентов чата.

**Задачи:**
- Создать стили для компонентов ChatSidebar, ChatHeader, MessageBubble
- Обеспечить правильное отображение списка чатов с поддержкой поиска и фильтрации
- Обеспечить отображение информации о текущем чате
- Обеспечить правильное оформление отдельных сообщений с поддержкой различных типов контента
- Интегрироваться с существующими компонентами проекта (Popup, SelectorOption, BaseButton)
- Реализовать hover эффекты и анимации для интерактивных элементов
- Добавить поддержку состояний загрузки и ошибок

**Ожидаемый результат:** Полный набор стилей для всех компонентов чата с поддержкой интерактивности и состояний.

## Этап 6: Интеграция с навигацией

### 6.1 Обновление SideNavigate компонента
**Цель:** Добавить кнопку чата в боковую навигацию приложения.

**Задачи:**
- Модифицировать файл `react-app/src/widgets/side-navigate/ui/side-navigate.tsx` для добавления кнопки чата в навигацию
- Добавить новую кнопку с иконкой чата
- Интегрировать с системой управления состоянием элементов через `openElement` и `isElementOpen`
- Обеспечить правильное отображение активного состояния
- Добавить поддержку горячих клавиш для быстрого доступа к чату
- Интегрироваться с существующей системой переводов для подсказок
- Следовать существующему паттерну навигационных элементов

**Ожидаемый результат:** Кнопка чата в боковой навигации с поддержкой всех функций навигации.

### 6.2 Обновление Main компонента
**Цель:** Интегрировать компонент чата в основную страницу приложения.

**Задачи:**
- Модифицировать файл `react-app/src/pages/main/ui/main.tsx` для интеграции компонента чата
- Добавить импорт компонента Chat
- Интегрировать с системой управления состоянием элементов
- Обеспечить правильное отображение чата при активации
- Добавить поддержку условного рендеринга
- Интегрироваться с существующей структурой страницы
- Следовать существующему паттерну отображения виджетов

**Ожидаемый результат:** Компонент чата интегрирован в основную страницу с поддержкой условного отображения.

## Этап 7: Обновление типов

### 7.1 Создание типов для chat slice
**Цель:** Создать типы для управления состоянием чатов в Redux.

**Задачи:**
- Создать файл типов `react-app/src/shared/models/chat-slice/types/chat-slice.ts` с интерфейсами для управления состоянием чатов
- Определить интерфейсы `ChatMessage`, `ChatData`, `ChatFile`, `ChatState` с полным описанием всех необходимых полей
- Обеспечить совместимость с существующими типами проекта
- Добавить поддержку всех операций с чатами
- Интегрироваться с системой типов Redux
- Обеспечить типобезопасность при работе с состоянием чатов

**Ожидаемый результат:** Полный набор типов для chat slice с поддержкой всех операций.

### 7.2 Обновление централизованных типов
**Цель:** Интегрировать типы чатов в общую систему типов проекта.

**Задачи:**
- Обновить файлы централизованных типов для включения типов чатов в общую систему типов проекта
- Добавить экспорты типов чатов в соответствующие индексные файлы
- Обеспечить доступность типов во всех частях приложения
- Интегрироваться с существующей системой типов
- Добавить поддержку импорта типов чатов
- Обеспечить консистентность типов по всему проекту

**Ожидаемый результат:** Типы чатов интегрированы в общую систему типов проекта.

## План поэтапной реализации

### Этап 1: Подготовка инфраструктуры (1-2 дня)
Создание FileSystemService в Electron с поддержкой атомарных операций записи, настройка IPC обработчиков для чатов с использованием существующего IpcHandler, обновление preload API для безопасного доступа к файловой системе, создание базовых типов для чатов с полной типизацией.

### Этап 2: Backend интеграция (2-3 дня)
Расширение feature-provider для поддержки режима чата с контекстом, интеграция с существующей системой useModel без нарушения текущей функциональности, тестирование IPC коммуникации и обработки ошибок, создание Redux слайса для управления состоянием чатов.

### Этап 3: UI компоненты (3-4 дня)
Создание основных UI компонентов чата в соответствии с дизайн-системой проекта, реализация стилей с использованием существующих CSS переменных, интеграция с системой навигации и управлением состоянием элементов, добавление анимаций и переходов для улучшения пользовательского опыта.

### Этап 4: Интеграция и тестирование (2-3 дня)
Полная интеграция всех компонентов с тестированием функциональности, оптимизация производительности с учетом больших объемов данных, обработка edge cases и ошибок, тестирование на различных сценариях использования.

### Этап 5: Полировка и документация (1-2 дня)
Финальная полировка UI/UX с учетом обратной связи, создание документации для разработчиков и пользователей, тестирование на различных платформах и размерах экрана, подготовка к релизу с проверкой всех требований безопасности.

## Технические детали

### Формат хранения чатов
Чаты сохраняются в JSON формате в папке `userData/chats/` с уникальными именами файлов. Каждый файл содержит полную информацию о чате включая метаданные, массив сообщений с поддержкой Markdown, временные метки создания и обновления, информацию о модели и контексте. JSON формат обеспечивает читаемость и возможность ручного редактирования при необходимости.

### Структура папок
Папка `chats` создается автоматически в `userData` при первом запуске приложения. Файлы чатов именуются по шаблону `chat_[timestamp].json` для обеспечения уникальности. Резервные копии создаются автоматически при обновлении файлов. Индексный файл может быть добавлен для быстрого поиска и фильтрации чатов.

### Безопасность
Все операции с файлами выполняются исключительно в main процессе Electron для обеспечения безопасности. Валидация данных осуществляется на всех уровнях - от IPC до UI компонентов. Размер файлов чатов ограничивается для предотвращения проблем с производительностью. Автоматическое резервное копирование защищает от потери данных при сбоях.

### Производительность
Ленивая загрузка сообщений реализуется для больших чатов с поддержкой пагинации. Виртуализация списка сообщений обеспечивает плавную работу с большим количеством сообщений. Кэширование часто используемых чатов в памяти ускоряет доступ к данным. Оптимизация re-renders через правильное использование React hooks и селекторов.

## Возможные проблемы и решения

### Проблема: Большие файлы чатов
**Решение:** Реализовать пагинацию сообщений с загрузкой по частям, сжатие старых сообщений в архивные форматы, ограничение максимального количества сообщений в одном чате, автоматическое архивирование старых чатов.

### Проблема: Конфликты при одновременном редактировании
**Решение:** Реализовать систему блокировок файлов с таймаутом, версионность файлов с возможностью отката изменений, уведомления о конфликтах с предложением разрешения, автоматическое сохранение промежуточных состояний.

### Проблема: Потеря данных при сбоях
**Решение:** Автоматическое сохранение каждые 30 секунд и при каждом сообщении, создание контрольных точек для восстановления состояния, дублирование критических данных в нескольких местах, мониторинг целостности файлов.

### Проблема: Производительность при большом количестве чатов
**Решение:** Индексация чатов с метаданными для быстрого поиска, ленивая загрузка списка чатов с виртуализацией, кэширование часто используемых данных, оптимизация алгоритмов поиска и фильтрации.

## Заключение

Данный план обеспечивает поэтапную реализацию чата с контекстом и локальным хранением в проекте Underlator. Архитектура построена на существующих компонентах и принципах проекта, что обеспечивает совместимость и поддерживаемость кода.

Ключевые преимущества реализации:
- Использование существующей инфраструктуры без дублирования функциональности
- Соответствие принципам FSD и Service Layer Architecture
- Безопасность и конфиденциальность данных через локальное хранение
- Расширяемость и возможность добавления новых функций в будущем
- Интеграция с существующей системой управления моделями и переводами
- Поддержка Markdown формата для ответов LLM моделей
- Адаптивный дизайн для различных размеров экрана
- Полная типизация для обеспечения надежности кода
