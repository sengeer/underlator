# Aрхитектурный план рефакторинга Underlator: Electron + React с интеграцией TypeScript и Ollama версии 3.0

## Общий контекст проекта

**Underlator** - десктопное приложение для конфиденциального перевода и анализа документов с использованием локальных LLM. Архитектура: React (frontend) + Electron (backend).

**Ключевые требования:**
- Работа с чувствительными данными (юристы, врачи, госслужащие)
- Только локальные LLM, никаких внешних HTTP запросов с данными пользователей
- Поддержка зоопарка моделей Ollama
- Полный отказ от @huggingface/transformers
- Прямая интеграция Ollama через HTTP API
- Сохранение Feature-Sliced Design на frontend
- Полная поддержка TypeScript в Electron backend

## Файловая архитектура

### **electron-app/src/**
```
src/
├── main.ts                    # Electron main process (TypeScript)
├── preload.ts                 # Preload script (TypeScript)
├── model.js                   # Legacy: TranslationPipeline (для удаления)
├── worker.js                  # Legacy: Worker для transformers (для удаления)
├── services/
│   ├── index.ts               # НОВЫЙ: Централизованный экспорт сервисов
│   ├── ollama-manager.ts      # Управление Ollama через electron-ollama
│   ├── ollama-api.ts          # HTTP клиент для Ollama API
│   ├── model-catalog.ts       # Получение каталога моделей
│   └── model-downloader.js    # Legacy: Скачивание моделей (для удаления)
├── types/
│   ├── index.ts               # НОВЫЙ: Централизованный экспорт типов
│   ├── ollama.types.ts        # Типы для Ollama API
│   ├── models.types.ts        # Типы для моделей
│   ├── generation.types.ts   # Типы для генерации
│   ├── catalog.types.ts       # Типы для каталога моделей
│   ├── parser.types.ts        # Типы для HTML парсера
│   ├── preload.types.ts       # Типы для preload скрипта
│   └── electron.d.ts          # Типы для Electron API
├── utils/
│   ├── ipc-handlers.ts        # IPC обработчики и утилиты
│   ├── error-handler.ts       # Обработка ошибок
│   └── html-parser.ts         # HTML парсер для каталога моделей
└── constants/
    ├── ollama.constants.ts    # Константы Ollama
    └── catalog.constants.ts   # Константы каталога
```

## Этап 1: Интеграция TypeScript в Electron проект

### 1.1 Установка TypeScript зависимостей и настройка tsconfig.json для Electron backend
**Цель:** Добавить полную поддержку TypeScript в Electron проект с правильной конфигурацией.

**Задачи:**
- Установить typescript, @types/node, @types/electron в package.json
- Создать tsconfig.json с настройками для Electron backend
- Настроить target ES2020, module commonjs, strict mode
- Добавить поддержку decorators и experimental features
- Настроить правильные пути для src/ и dist/

**Ожидаемый результат:** Полностью настроенный TypeScript для Electron backend с правильной конфигурацией компиляции.

### 1.2 Настройка webpack для транспиляции TypeScript в JavaScript
**Цель:** Настроить webpack для корректной работы с TypeScript файлами.

**Задачи:**
- Добавить ts-loader в webpack.config.js
- Настроить правила для .ts и .tsx файлов
- Обновить entry points для main.ts, preload.ts
- Настроить resolve.extensions для TypeScript
- Убедиться что webpack корректно транспилирует TypeScript

**Ожидаемый результат:** Webpack корректно транспилирует TypeScript файлы в JavaScript для Electron.

### 1.3 Миграция существующих JavaScript файлов на TypeScript
**Цель:** Переписать основные файлы Electron на TypeScript с правильной типизацией.

**Задачи:**
- Переименовать main.js в main.ts и добавить типизацию
- Переименовать preload.js в preload.ts и добавить типизацию
- Добавить типы для Electron API и IPC
- Создать интерфейсы для основных структур данных
- Убедиться что все импорты и экспорты корректно типизированы

**Ожидаемый результат:** Основные файлы Electron полностью переписаны на TypeScript с правильной типизацией.

## Этап 2: Создание инфраструктуры для работы с Ollama

### 2.1 Установка electron-ollama и создание OllamaManager для управления Ollama в Electron Main Process
**Цель:** Создать простую систему управления Ollama через electron-ollama библиотеку.

**Задачи:**
- Установить electron-ollama в package.json
- Создать src/services/ollama-manager.ts для управления Ollama
- Реализовать методы initialize(), startOllama(), stopOllama(), isOllamaRunning()
- Настроить автоматическую установку Ollama при первом запуске
- Добавить обработку ошибок и fallback логику

**Ожидаемый результат:** Простая система управления Ollama, которая автоматически устанавливает и запускает Ollama при старте Electron.

### 2.2 Создание HTTP клиента для работы с Ollama API
**Цель:** Создать простой и надежный HTTP клиент для взаимодействия с Ollama API.

**Задачи:**
- Создать src/services/ollama-api.ts для HTTP вызовов к Ollama
- Реализовать методы generate(), installModel(), removeModel(), listModels()
- Добавить поддержку streaming ответов для генерации
- Реализовать простую обработку ошибок и retry логику
- Добавить поддержку AbortController для отмены операций

**Ожидаемый результат:** Надежный HTTP клиент для работы с Ollama API, готовый для использования через IPC.

### 2.3 Создание типов и интерфейсов для Ollama API
**Цель:** Определить четкие типы для всех операций с Ollama API и исправить возникшие TypeScript ошибки.

**Задачи:**
- Испрвить TypeScript ошибки у файлов в electron-app/src/
- Обновить electron-app/src/types/ollama.types.ts с интерфейсами для API
- Создать electron-app/src/types/models.types.ts с типами для моделей
- Создать electron-app/src/types/generation.types.ts с типами для генерации
- Добавить типы для streaming ответов и прогресса
- Создать типы для ошибок и статусов

**Ожидаемый результат:** Полный набор типов для работы с Ollama API, обеспечивающий типобезопасность и отсутствие TypeScript ошибок по проекту.

## Этап 3: Создание IPC системы для взаимодействия с Ollama

### 3.1 Модификация main.ts для запуска Ollama и создания IPC handlers
**Цель:** Создать простую систему IPC для прямого взаимодействия с Ollama HTTP API.

**Задачи:**
- Модифицировать main.ts для запуска Ollama через OllamaManager
- Создать IPC handlers для ollama:generate, models:install, models:remove, models:list
- Интегрировать OllamaApi сервис с IPC handlers
- Добавить обработку ошибок и валидацию входных данных
- Настроить правильную последовательность запуска

**Ожидаемый результат:** Electron main process корректно запускает Ollama и предоставляет IPC API для взаимодействия с frontend.

### 3.2 Создание утилит для обработки IPC сообщений
**Цель:** Создать вспомогательные утилиты для работы с IPC и обработки ошибок.

**Задачи:**
- Создать src/utils/ipc-handlers.ts для централизованной обработки IPC
- Создать src/utils/error-handler.ts для обработки ошибок
- Добавить валидацию IPC сообщений
- Реализовать логирование IPC операций
- Создать утилиты для форматирования ответов

**Ожидаемый результат:** Надежная система обработки IPC сообщений с правильной обработкой ошибок.

### 3.3 Создание констант и конфигурации для Ollama
**Цель:** Централизовать все константы и настройки для Ollama.

**Задачи:**
- Создать src/constants/ollama.constants.ts
- Определить URL endpoints для Ollama API
- Добавить настройки таймаутов и retry попыток
- Создать константы для статусов и ошибок
- Добавить настройки для различных типов моделей

**Ожидаемый результат:** Централизованная конфигурация для всех операций с Ollama.

## Этап 4: Создание нового провайдера embedded-ollama на frontend

### 4.1 Создание структуры папок shared/providers/embedded-ollama/
**Цель:** Создать новый провайдер который заменит провайдер local.

**Задачи:**
- Создать папку shared/providers/embedded-ollama/
- Создать index.ts с экспортом embeddedOllamaProvider
- Создать types.ts с типами для нового провайдера
- Создать api.ts с методами для взаимодействия с Electron IPC
- Настроить правильную структуру файлов согласно FSD архитектуре

**Ожидаемый результат:** Полностью готовая структура нового провайдера с правильным размещением файлов.

### 4.2 Реализация embeddedOllamaProvider с единым методом generate
**Цель:** Создать провайдер который работает через Electron IPC и обрабатывает все типы задач.

**Задачи:**
- Реализовать embeddedOllamaProvider.generate() метод
- Добавить поддержку как строк, так и массивов строк
- Интегрировать с window.electron.ollama.generate() через IPC
- Реализовать обработку статусов (progress, message, complete, error)
- Добавить поддержку AbortController для отмены операций
- Реализовать правильную обработку контекстного перевода

**Ожидаемый результат:** Рабочий провайдер который заменяет функциональность local провайдера.

### 4.3 Обновление системы провайдеров
**Цель:** Интегрировать новый провайдер в существующую систему провайдеров.

**Задачи:**
- Обновить shared/providers/index.ts
- Добавить embedded-ollama в список провайдеров
- Обновить ProviderType для включения 'embedded-ollama'
- Обновить getModelUseProvider функцию
- Подготовить к удалению старых провайдеров

**Ожидаемый результат:** Система провайдеров работает с новым embedded-ollama провайдером.

## Этап 5: Создание системы получения каталога моделей Ollama

### 5.1 Создание сервиса для получения каталога моделей
**Цель:** Создать систему для получения полного списка доступных моделей Ollama.

**Задачи:**
- Создать src/services/model-catalog.ts для получения каталога
- Реализовать методы getAvailableModels(), getModelInfo(), searchModels()
- Интегрировать с Ollama Registry API для получения списка моделей
- Добавить кэширование каталога для оптимизации
- Реализовать фильтрацию и поиск по моделям

**Ожидаемый результат:** Система для получения полного каталога доступных моделей Ollama.

### 5.2 Создание типов для каталога моделей
**Цель:** Определить типы для работы с каталогом моделей.

**Задачи:**
- Создать src/types/catalog.types.ts
- Определить интерфейсы для ModelCatalog, CatalogModel, ModelMetadata
- Добавить типы для фильтрации и поиска
- Создать типы для статусов моделей (available, installed, downloading)
- Добавить типы для метаданных моделей (размер, описание, теги)

**Ожидаемый результат:** Полный набор типов для работы с каталогом моделей.

### 5.3 Создание IPC handlers для каталога моделей
**Цель:** Создать IPC API для получения каталога моделей.

**Задачи:**
- Добавить IPC handlers для catalog:get, catalog:search, catalog:get-model-info
- Интегрировать ModelCatalog сервис с IPC handlers
- Добавить поддержку фильтрации через IPC
- Реализовать кэширование на уровне IPC
- Добавить обработку ошибок и валидацию
- Добавить на стороне React front-end функции для тестирования новых IPC в файл react-app/src/widgets/settings/tests/ipc-tester.js и кнопки в react-app/src/widgets/settings/ui/index.tsx

**Ожидаемый результат:** IPC API для получения каталога моделей через frontend.

### 5.4 Улучшение HTML парсера для получения каталога всех квантизаций
**Цель:** Обновить HTML парсер для получения полного списка вариантов моделей которые можно установить в Ollama.

**Задачи:**
- Улучшить utils/html-parser.ts, чтобы он создавал каталог моделей со всеми варантами квантизаций
- Если требуется обновить типы types/parser.types.ts
- Следить что бы не сломалась логика catalog:get, catalog:get с forceRefresh, catalog:search с фильтрами и catalog:get-model-info

**Ожидаемый результат:** Улучшенная логика которая предоставляет полный каталог моделей, а не каталог стандартных моделей без квантизации.

## Этап 6: Рефакторинг SelectorPopup и создание универсальных UI компонентов

### 6.1 Создание компонента Search для поиска в списках
**Цель:** Создать переиспользуемый компонент поиска для использования в SelectorPopup и других списках.

**Задачи:**
- Создать shared/ui/search/index.tsx с базовой функциональностью поиска
- Реализовать поддержку debounce для оптимизации производительности
- Добавить поддержку placeholder и кастомных стилей
- Создать shared/ui/search/types.ts с интерфейсами для Search
- Добавить поддержку очистки поиска и горячих клавиш
- Реализовать поддержку иконки поиска (присутствует в react-app/src/shared/assets/icons)
- Придерживаться минималистичного собственного UI Kit основанного на четырёх корневых цветах: main, background, accent, foreground и использовании rem (можно подглянуть в другие .scss компонентов)

**Ожидаемый результат:** Переиспользуемый компонент Search готовый для интеграции в SelectorPopup.

### 6.2 Создание компонента SelectorOption с множественными состояниями
**Цель:** Создать универсальный компонент пункта списка который поддерживает простые и сложные состояния согласно SOLID принципам.

**Задачи:**
- Создать shared/ui/selector-option/index.tsx как основной компонент
- Реализовать паттерн Strategy для рендеринга разных режимов
- Создать shared/ui/selector-option/simple-mode.tsx для простых пунктов (TextButton)
- Создать shared/ui/selector-option/complex-mode.tsx для сложных пунктов
- Добавить shared/ui/selector-option/types.ts с интерфейсами для всех состояний
- Реализовать поддержку состояний: simple, loading, installed, available, error
- Добавить поддержку кастомных стилей и анимаций

**Ожидаемый результат:** Универсальный SelectorOption компонент с поддержкой всех необходимых состояний.

### 6.3 Интеграция ленивой загрузки в компонент Popup
**Цель:** Реализовать логику ленивой загрузки и интегрировать её в компонент Popup с помощью Intersection Observer API

**Задачи:**
- Создать react-app/src/shared/lib/hooks/use-intersection-observer/index.ts основной хук
- Создать react-app/src/shared/lib/hooks/use-intersection-observer/types.ts для типов
- Добавить комонент ленивой загрузки react-app/src/shared/ui/popup/lazy-list-item.tsx
- Добавить типы для ленивой загрузки в модуль react-app/src/shared/ui/popup/types.ts

**Ожидаемый результат:** Оптимизированный Popup с поддержкой ленивой загрузки.

### 6.4 Создание нового компонента PopupWithSearch для поддержки поиска в модальном окне
**Цель:** Создать новый компонент PopupWithSearch который расширяет базовый Popup по приницпу LSP, добавляя компонент Search в модальное окно.

**Задачи:**
- Создать react-app/src/shared/ui/popup-with-search/index.tsx
- Изменить Popup если того требует расширение по LSP
- Если требуется, добавить типы для нового расширенного компонента в react-app/src/shared/ui/popup-with-search/types.ts

**Ожидаемый результат:** Переиспользуемый независимый компонент PopupWithSearch готовый к дальнейшей интеграции с Electron API.

## Этап 7: Интеграция взаимодействия с Electron API в React приложение

### 7.1 Создание удобных функций для обращения к Electron API
**Цель:** Создать модуль react-app/src/widgets/settings/api/embedded-ollama-electron-api.ts который позволит: получать каталог моделей, выполнять простой поиск по названию, выполнять фильтрацию, сортировку моделей, загружать модель с прогрессом, удалять модель.

**Задачи:**
- Создать индексный файл react-app/src/widgets/settings/api/index.ts
- Создать react-app/src/widgets/settings/api/embedded-ollama-electron-api.ts для взаимодействия с Electron API
- Создать react-app/src/widgets/settings/api/types.ts для типов взаимодействия с Electron API
- Реализовать функцию для запросов получения каталога моделей для рендера списка SelectorOption на его основе в будующем
- Реализовать функцию для запросов поиска, фильтрации и сортировки моделей по названию под использование компонентом Search и models-slice в будующем
- Добавить функцию для запросов загрузки модели с возможностью отображения прогресса под интеграцию с компонентом SelectorOption и models-slice в будующем
- Создать функцию удаления модели под интеграцию с компонентом  SelectorOption в будующем

**Ожидаемый результат:** Подготовить модуль для использования Electron API, готовый к интеграции с логикой управления.

### 7.2 Реализация Redux slice для управления моделями в Settings
**Цель:** Создать централизованное управление состоянием моделей в контексте Settings виджета.

**Задачи:**
- Создать widgets/settings/model/manage-embedded-ollama-slice.ts с initialState для каталога и процесса установки
- Добавить reducers для setCatalog, setInstallationProgress, setSearchQuery
- Реализовать async thunks который взаимодействует с модулем api/index.ts
- Добавить обработку состояний loading, error, success для каждой операции
- Реализовать поддержку фильтрации и сортировки моделей
- Добавить поддержку кэширования и оптимизации запросов

**Ожидаемый результат:** Redux slice для частичного управления моделями в контексте Settings виджета.

### 7.3 Создание компонента который связывает запросы Electron API с подготовленными React компонентами
**Цель:** Создать компонент ManageModels с логикой связанной с интеграцией, должен возвращать PopupWithSearch который будет импортироваться в Settings.

**Задачи:**
- Создать react-app/src/widgets/settings/ui/manage-embedded-ollama.tsx компонент который соединяет в себе всю логику взаимодейтвия с провайдером Embedded Ollama
- Добавить интеграцию с provider-settings-slice как в Settings в котором указывается выбранная модель
- Создать react-app/src/widgets/settings/ui/types.ts для типов
- Интегрировать компонент в Settings для провайдера Embedded Ollama

**Ожидаемый результат:** UI с основными действиями для управления моделями Embedded Ollama внутри Settings виджета с оптимизированным рендером и расширяемой архитектурой.

## Этап 8: Интеграция с существующими компонентами

### 8.1 Модификация useModel хука для работы с новым провайдером
**Цель:** Обновить основной хук для работы с новым провайдером и поддержки выбора моделей.

**Задачи:**
- Модифицировать useModel для использования 'embedded-ollama' провайдера
- Добавить поддержку выбора модели из списка доступных через Redux store
- Обновить generate() метод для передачи параметров модели
- Добавить поддержку параметров генерации (temperature, maxTokens)
- Интегрировать с новым Redux store для моделей
- Сохранить существующую логику для контекстного перевода
- Добавить поддержку динамического переключения моделей

**Ожидаемый результат:** Обновленный useModel хук который работает с новым провайдером и поддерживает выбор моделей.

### 8.2 Обновление Settings компонента с интеграцией управления моделями
**Цель:** Интегрировать компоненты управления моделями в Settings и упростить интерфейс используя новые компоненты.

**Задачи:**
- Интегрировать model-management компонент в основной Settings компонент
- Заменить старые селекторы на новые композитные компоненты (language-selector, provider-selector)
- Упростить интерфейс настроек, убрав старые элементы управления моделями
- Добавить выбор провайдера 'embedded-ollama' как единственного варианта
- Интегрировать с новым Redux store для моделей в Settings
- Обновить логику отображения статуса моделей через SelectorOption
- Упростить UI, оставив только необходимые элементы
- Добавить поддержку выбора модели из каталога через model-management компонент

**Ожидаемый результат:** Обновленный Settings компонент с полной интеграцией управления моделями и современных UI компонентов.

### 8.3 Обновление других виджетов с поддержкой выбора моделей
**Цель:** Обеспечить корректную работу всех виджетов с новым провайдером и возможностью выбора моделей.

**Задачи:**
- Обновить pdf-viewer для работы с 'embedded-ollama' провайдером
- Добавить поддержку выбора модели в интерфейсе pdf-viewer
- Обновить text-translator для работы с новым провайдером
- Добавить поддержку выбора модели в интерфейсе text-translator
- Убедиться что контекстный перевод работает корректно с выбранной моделью
- Обновить логику обработки ошибок и статусов
- Протестировать все сценарии использования с разными моделями

**Ожидаемый результат:** Все виджеты корректно работают с новым провайдером и поддерживают выбор моделей.

## Этап 9: Удаление старых провайдеров и зависимостей

### 9.1 Удаление старых провайдеров
**Цель:** Полностью очистить проект от старых провайдеров и их кода.

**Задачи:**
- Удалить shared/providers/local/ папку полностью
- Удалить shared/apis/ollama/ папку
- Обновить shared/providers/index.ts
- Удалить ProviderType 'Electron IPC' и 'Ollama'
- Обновить все импорты и ссылки

**Ожидаемый результат:** Проект полностью очищен от старых провайдеров.

### 9.2 Удаление @huggingface/transformers
**Цель:** Убрать все упоминания и использование @huggingface/transformers.

**Задачи:**
- Удалить @huggingface/transformers из package.json
- Удалить src/model.js файл полностью
- Удалить src/worker.js файл полностью
- Удалить src/services/model-downloader.js файл полностью
- Обновить main.ts, убрав все ссылки на старые сервисы
- Удалить все импорты и использование старых модулей

**Ожидаемый результат:** Electron backend полностью очищен от @huggingface/transformers.

### 9.3 Очистка зависимостей
**Цель:** Оптимизировать зависимости и упростить процесс сборки.

**Задачи:**
- Удалить неиспользуемые зависимости из package.json
- Обновить скрипты сборки для работы с TypeScript
- Проверить и обновить все devDependencies
- Убедиться что сборка работает корректно

**Ожидаемый результат:** Оптимизированный package.json с правильными зависимостями для TypeScript.

## Этап 10: Тестирование и финальная оптимизация

### 10.1 Комплексное тестирование системы
**Цель:** Убедиться что все компоненты системы работают корректно вместе.

**Задачи:**
- Протестировать запуск Ollama через electron-ollama в Electron
- Проверить корректность IPC коммуникации между frontend и backend
- Протестировать работу нового embedded-ollama провайдера
- Проверить корректность контекстного перевода
- Протестировать установку и удаление моделей через Ollama API
- Проверить работу с различными типами задач
- Протестировать UI компоненты для управления моделями
- Протестировать получение каталога моделей
- Проверить работу обновленного SelectorPopup

**Ожидаемый результат:** Полностью рабочая система с корректной интеграцией всех компонентов.

### 10.2 Финальная оптимизация и настройка
**Цель:** Оптимизировать систему и убедиться в соблюдении требований безопасности.

**Задачи:**
- Проверить отсутствие внешних HTTP запросов с данными пользователей
- Оптимизировать производительность генерации через Ollama HTTP API
- Настроить правильные параметры для различных типов моделей
- Проверить корректность работы с большими документами
- Оптимизировать UI для лучшего пользовательского опыта
- Провести финальное тестирование всех сценариев использования
- Убедиться в правильной работе TypeScript и IPC системы
- Оптимизировать кэширование каталога моделей

**Ожидаемый результат:** Оптимизированная, безопасная и производительная система с полной поддержкой TypeScript.

## Ключевые принципы архитектуры

✅ **TypeScript поддержка** - полная типизация Electron backend
✅ **Прямая интеграция** - React → IPC → Electron → HTTP → Ollama
✅ **Простота** - понятная архитектура без лишних слоев
✅ **Производительность** - меньше hop'ов, быстрее работа
✅ **Красивый UI** - современные компоненты для управления моделями
✅ **FSD compliance** - строгое соблюдение Feature-Sliced Design без нарушения границ слоев
✅ **SOLID принципы** - модульная архитектура компонентов
✅ **Безопасность** - полная конфиденциальность данных
✅ **Каталог моделей** - полный список доступных моделей Ollama
✅ **Виртуализация** - оптимизированный рендер для больших списков
✅ **Переиспользование** - универсальные UI компоненты (SelectorOption, Search, OptimizedList)
✅ **Композиция** - гибкие композитные компоненты для разных сценариев
✅ **Правильная структура** - компоненты управления моделями в Settings виджете согласно FSD

## Ожидаемый результат

После завершения всех этапов у вас будет:
- **TypeScript backend** - полностью типизированный Electron backend
- **Упрощенная архитектура** - Electron + React с прямой интеграцией Ollama
- **Высокая производительность** - нативные Ollama модели через HTTP API
- **Красивый UI** - современные компоненты для управления моделями
- **Каталог моделей** - полный список доступных моделей Ollama
- **Масштабируемость** - легко добавлять новые модели и возможности
- **Безопасность** - полная конфиденциальность данных
- **User-friendly** - автоматическая установка и красивое управление моделями
- **Оптимизированный рендер** - виртуализированные оптимизированные списки для тысяч моделей
- **Переиспользуемые компоненты** - SelectorOption, Search, OptimizedList для других проектов
- **Гибкая композиция** - готовые композитные компоненты для разных сценариев
- **SOLID архитектура** - модульные, тестируемые и поддерживаемые компоненты
- **FSD compliance** - правильная структура без нарушения границ слоев
- **Интегрированное управление моделями** - все компоненты управления моделями в Settings виджете

Каждый этап можно делегировать отдельному агенту, который получит детальные инструкции и сможет выполнить задачу качественно.