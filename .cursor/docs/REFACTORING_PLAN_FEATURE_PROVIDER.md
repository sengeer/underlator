# Архитектурный план рефакторинга Feature Provider и системы промптов

## Общий контекст проекта

**Ключевые требования для рефакторинга:**
- Соблюдение принципов SOLID, особенно Single Responsibility Principle
- Оптимизация производительности с учетом big-O notation
- Поддержка редактируемых системных промптов через UI
- Улучшение поддерживаемости и тестируемости кода
- Соответствие архитектуре Feature-Sliced Design (FSD)
- Использование функционального программирования для React (front-end)

## Анализ текущей архитектуры

### Существующие компоненты для рефакторинга

**React Frontend (FSD Architecture):**
- `feature-provider.ts` - центральный модуль обработки запросов к LLM с нарушением SRP
- `use-model.ts` - хук для работы с LLM моделями
- `contextual-translation.ts` - утилиты для контекстного перевода
- `chunk-text-manager.ts` - управление текстовыми фрагментами
- `create-contextual-prompt` - HOF для генерации промптов контекстного перевода
- Redux store для управления состоянием
- Система настроек провайдеров

**Проблемы текущей реализации:**
- `handleChat` функция нарушает SRP, выполняя 8 различных ответственностей
- Промпты захардкожены в коде, нет возможности редактирования через UI
- Избыточная вложенность в функциях обработки
- Отсутствие разделения ответственности между компонентами
- Сложность тестирования из-за монолитных функций

## Архитектурный план реализации

## Этап 1: Создание системы управления промптами

### 1.1 Создание модуля хранения промптов с типами и константами

**Цель:** Создать централизованную систему управления промптами с поддержкой шаблонов, плейсхолдеров и хранения в localStorage/Redux.

**Задачи:**
- Создать файл типов `react-app/src/shared/lib/utils/prompt-manager/types/prompt-manager.ts` с интерфейсами для системы промптов включая `PromptTemplate` с идентификатором шаблона, содержимым с плейсхолдерами, метаданными включающими описание, режим использования, обязательные плейсхолдеры, `PromptConfig` с настройками для различных режимов включая chat, contextualTranslation, simpleTranslation, instruction, `PromptStorage` для управления хранением промптов, `PromptValidationResult` для результатов валидации промптов
- Создать файл констант `react-app/src/shared/lib/utils/prompt-manager/constants/prompt-manager.ts` с дефолтными шаблонами промптов для всех режимов включая `DEFAULT_CONTEXTUAL_TRANSLATION_PROMPT`, `DEFAULT_CHAT_SYSTEM_PROMPT`, `DEFAULT_CHAT_RULES_PROMPT`, `DEFAULT_SIMPLE_TRANSLATION_PROMPT`, `DEFAULT_INSTRUCTION_PROMPT`
- Создать файл `react-app/src/shared/lib/utils/prompt-manager/prompt-templates.ts` с функцией `getPromptTemplate` для получения шаблона по идентификатору, функцией `getDefaultTemplates` для получения всех дефолтных шаблонов, функцией `validateTemplate` для валидации шаблонов с проверкой обязательных плейсхолдеров
- Создать файл `react-app/src/shared/lib/utils/prompt-manager/prompt-storage.ts` с функцией `loadPrompts` для загрузки промптов из localStorage, функцией `savePrompts` для сохранения промптов в localStorage, функцией `resetToDefaults` для сброса к дефолтным значениям, функцией `migratePrompts` для автоматической миграции при обновлении структуры
- Создать файл `react-app/src/shared/lib/utils/prompt-manager/prompt-manager.ts` с классом `PromptManager` для управления промптами, методом `getPrompt` для получения промпта по режиму, методом `updatePrompt` для обновления промпта, методом `validatePrompt` для валидации промпта перед сохранением, методом `getPromptWithPlaceholders` для получения промпта с подстановкой плейсхолдеров
- Реализовать поддержку плейсхолдеров включая `{sourceLanguage}`, `{targetLanguage}`, `{chunkDelimiter}`, `{combinedText}`, `{ragContext}`, `{historyMessages}` с валидацией обязательных плейсхолдеров
- Добавить кэширование промптов в памяти для оптимизации производительности
- Реализовать обработку ошибок загрузки и сохранения промптов с fallback на дефолтные значения
- Добавить логирование операций с промптами для отладки
- Обеспечить типобезопасность всех операций с промптами
- Создать индексный файл `react-app/src/shared/lib/utils/prompt-manager/index.ts` для экспорта всех публичных API

**Ожидаемый результат:** Полнофункциональный модуль управления промптами с поддержкой шаблонов, плейсхолдеров, валидации и хранения в localStorage с полной типизацией.

### 1.2 Создание HOF для построения промптов

**Цель:** Создать функцию высшего порядка для композиции промптов из шаблонов с поддержкой плейсхолдеров и валидации.

**Задачи:**
- Создать файл типов `react-app/src/shared/lib/hofs/create-prompt-builder/types/create-prompt-builder.ts` с интерфейсами для билдера промптов включая `PromptBuilder` как функцию принимающую данные и возвращающую промпт, `PromptBuilderConfig` с настройками билдера включая валидацию плейсхолдеров, обработку ошибок, `PlaceholderMap` для маппинга плейсхолдеров на значения
- Создать файл `react-app/src/shared/lib/hofs/create-prompt-builder/create-prompt-builder.ts` с функцией `createPromptBuilder` принимающей шаблон промпта и конфигурацию плейсхолдеров, возвращающей каррированную функцию для построения промпта, реализовать подстановку плейсхолдеров через функцию `replacePlaceholders` с поддержкой вложенных плейсхолдеров, реализовать валидацию обязательных плейсхолдеров перед построением промпта, добавить обработку ошибок при отсутствии обязательных плейсхолдеров, реализовать композицию промптов из нескольких шаблонов через функцию `composePrompts`
- Добавить поддержку условных плейсхолдеров для опциональных секций промпта
- Реализовать кэширование построенных промптов для одинаковых входных данных
- Добавить логирование операций построения промптов для отладки
- Обеспечить типобезопасность всех операций с билдерами промптов
- Создать индексный файл `react-app/src/shared/lib/hofs/create-prompt-builder/index.ts` для экспорта публичных API
- Добавить примеры использования в JSDoc комментариях

**Ожидаемый результат:** HOF функция для создания билдеров промптов с поддержкой плейсхолдеров, валидации и композиции, готовая для использования во всех режимах работы с LLM.

### 1.3 Миграция существующих промптов в prompt-manager

**Цель:** Перенести все существующие промпты из кода в систему prompt-manager с сохранением функциональности.

**Задачи:**
- Извлечь промпт контекстного перевода из `create-contextual-prompt.ts` в шаблон `DEFAULT_CONTEXTUAL_TRANSLATION_PROMPT`
- Извлечь системный промпт чата из `chat-context.ts` в шаблон `DEFAULT_CHAT_SYSTEM_PROMPT`
- Извлечь правила чата из `buildChatPrompt` в шаблон `DEFAULT_CHAT_RULES_PROMPT`
- Извлечь промпт простого перевода из `handleSimpleTranslation` в шаблон `DEFAULT_SIMPLE_TRANSLATION_PROMPT`
- Извлечь промпт инструкций из `handleInstruction` в шаблон `DEFAULT_INSTRUCTION_PROMPT`
- Создать функцию миграции для автоматического переноса промптов при первом запуске после обновления
- Добавить валидацию мигрированных промптов на корректность структуры
- Обеспечить обратную совместимость со старым кодом до полной миграции
- Добавить логирование процесса миграции для отладки
- Создать тесты для проверки корректности миграции всех промптов

**Ожидаемый результат:** Все существующие промпты успешно мигрированы в систему prompt-manager с сохранением функциональности и обратной совместимостью.

## Этап 2: Рефакторинг feature-provider.ts по принципу SRP

### 2.1 Создание сервисов для обработки чата

**Цель:** Разделить монолитную функцию `handleChat` на отдельные сервисы с четким разделением ответственности по принципу Single Responsibility Principle.

**Задачи:**
- Создать файл типов `react-app/src/shared/lib/utils/chat-handlers/types/chat-handlers.ts` с интерфейсами для всех chat handlers включая `ChatValidationResult`, `RAGContextResult`, `ChatContextResult`, `ChatPromptResult`, `ChatResponseResult`, `ChatHistoryResult`
- Создать файл `react-app/src/shared/lib/utils/chat-handlers/chat-validator.ts` с функцией `validateChatRequest` для валидации `chatId`, входного сообщения, конфигурации запроса, функцией `validateChatId` для проверки корректности идентификатора чата, функцией `validateMessage` для валидации текста сообщения
- Создать файл `react-app/src/shared/lib/utils/chat-handlers/chat-rag-loader.ts` с функцией `loadRagContext` для получения статистики коллекции RAG через IPC, функцией `searchRelevantDocuments` для поиска релевантных документов, функцией `formatRagContext` для форматирования RAG контекста в строку, функцией `handleRagErrors` для обработки ошибок RAG с информативными сообщениями
- Создать файл `react-app/src/shared/lib/utils/chat-handlers/chat-context-loader.ts` с функцией `loadChatContext` для загрузки контекста чата через IPC API, функцией `transformToChatContext` для преобразования данных IPC в `ChatContext`, функцией `handleContextErrors` для обработки ошибок загрузки контекста
- Создать файл `react-app/src/shared/lib/utils/chat-handlers/chat-prompt-builder.ts` с функцией `buildChatPromptWithContext` для построения промпта с использованием prompt-manager, функцией `getSystemPrompt` для получения системного промпта из prompt-manager, функцией `buildFullPrompt` для композиции финального промпта с использованием `buildChatPrompt` из chat-context utils, функцией `manageContextSummarization` для управления суммированием контекста при превышении лимитов
- Создать файл `react-app/src/shared/lib/utils/chat-handlers/chat-response-handler.ts` с функцией `createStreamingHandler` для создания обработчика streaming ответов, функцией `accumulateResponse` для накопления полного ответа, функцией `handleStreamingErrors` для обработки ошибок streaming, функцией `callModelResponseCallback` для вызова `onModelResponse` callback
- Создать файл `react-app/src/shared/lib/utils/chat-handlers/chat-history-saver.ts` с функцией `saveChatHistory` для сохранения истории чата через IPC, функцией `saveUserMessage` для сохранения сообщения пользователя, функцией `saveAssistantMessage` для сохранения ответа ассистента, функцией `handleSaveErrors` для обработки ошибок сохранения без прерывания выполнения
- Создать файл `react-app/src/shared/lib/utils/chat-handlers/chat-handler.ts` с функцией `handleChat` объединяющей все сервисы в единый поток обработки
- Создать индексный файл `react-app/src/shared/lib/utils/chat-handlers/index.ts` для экспорта всех handlers
- Добавить обработку ошибок на каждом этапе с информативными сообщениями
- Обеспечить типобезопасность всех операций
- Добавить логирование операций для отладки
- Создать unit тесты для каждого handler

**Ожидаемый результат:** Полностью разделенные сервисы для обработки чата с четким разделением ответственности, готовые для использования в рефакторенном `handleChat`.

### 2.2 Рефакторинг handleChat с использованием новых сервисов

**Цель:** Переписать функцию `handleChat` используя созданные сервисы для упрощения логики и улучшения читаемости.

**Задачи:**
- Модифицировать файл `react-app/src/shared/lib/hooks/use-model/feature-provider.ts` для замены старой реализации `handleChat` на новую
- Реализовать последовательность вызовов: валидация → параллельная загрузка RAG и контекста → построение промпта → генерация ответа → сохранение истории
- Использовать `Promise.all` для параллельной загрузки RAG контекста и контекста чата для оптимизации производительности
- Реализовать ранний возврат при ошибках валидации
- Добавить обработку ошибок на каждом этапе с информативными сообщениями через `callANotificationWithALog`
- Обеспечить корректную отписку от streaming событий в блоке `finally`
- Сохранить совместимость с существующим интерфейсом `ModelRequestContext`
- Добавить логирование ключевых этапов обработки для отладки
- Создать интеграционные тесты для проверки полного потока обработки чата
- Убедиться что производительность не ухудшилась после рефакторинга

**Ожидаемый результат:** Упрощенная и читаемая функция `handleChat` с четкой последовательностью операций и улучшенной обработкой ошибок.

### 2.3 Создание сервисов для других режимов работы

**Цель:** Создать аналогичные сервисы для режимов contextual translation, simple translation и instruction по образцу chat handlers.

**Задачи:**
- Создать файл типов `react-app/src/shared/lib/utils/translation-handlers/types/translation-handlers.ts` с интерфейсами для всех translation handlers
- Создать файл `react-app/src/shared/lib/utils/translation-handlers/contextual-translation-handler.ts` с функцией `handleContextualTranslation` для обработки контекстного перевода, функцией `validateContextualTranslationRequest` для валидации запроса, функцией `prepareContextualData` для подготовки данных через chunk-text-manager, функцией `buildContextualPrompt` для построения промпта через prompt-manager, функцией `processContextualResponse` для обработки ответа
- Создать файл `react-app/src/shared/lib/utils/translation-handlers/simple-translation-handler.ts` с функцией `handleSimpleTranslation` для обработки простого перевода, функцией `buildSimpleTranslationPrompt` для построения промпта через prompt-manager, функцией `handleTranslationResponse` для обработки streaming ответа
- Создать файл `react-app/src/shared/lib/utils/translation-handlers/instruction-handler.ts` с функцией `handleInstruction` для обработки инструкций, функцией `buildInstructionPrompt` для построения промпта через prompt-manager, функцией `handleInstructionResponse` для обработки streaming ответа
- Создать индексный файл `react-app/src/shared/lib/utils/translation-handlers/index.ts` для экспорта всех handlers
- Добавить обработку ошибок на каждом этапе
- Обеспечить типобезопасность всех операций
- Добавить логирование операций для отладки
- Создать unit тесты для каждого handler
- Обеспечить единообразие структуры с chat handlers

**Ожидаемый результат:** Полный набор сервисов для всех режимов работы с LLM с четким разделением ответственности и единообразной структурой.

## Этап 3: Оптимизация contextual-translation.ts

### 3.1 Упрощение логики и оптимизация производительности

**Цель:** Упростить логику функций в `contextual-translation.ts` и оптимизировать их производительность с учетом big-O notation.

**Задачи:**
- Модифицировать файл `react-app/src/shared/lib/utils/contextual-translation/contextual-translation.ts` для оптимизации функций
- Оптимизировать функцию `shouldUseContextualTranslation` до O(1) сложности через ранний возврат и упрощение условий
- Оптимизировать функцию `getContextualTranslationConfig` используя `Map` для O(1) поиска вместо объекта с O(n) в худшем случае
- Упростить функцию `validateContextualTranslationParams` удалив избыточные проверки, перенеся часть валидации в prompt-manager
- Добавить мемоизацию для часто вызываемых функций через кэширование результатов
- Удалить дублирование кода между функциями
- Улучшить читаемость кода через более понятные имена переменных и функций
- Добавить JSDoc комментарии с описанием сложности операций
- Создать unit тесты для проверки производительности оптимизированных функций
- Обеспечить обратную совместимость с существующим API

**Ожидаемый результат:** Оптимизированные функции в `contextual-translation.ts` с улучшенной производительностью и упрощенной логикой.

### 3.2 Интеграция с prompt-manager

**Цель:** Интегрировать `contextual-translation.ts` с системой prompt-manager для использования редактируемых промптов.

**Задачи:**
- Модифицировать функции в `contextual-translation.ts` для использования промптов из prompt-manager вместо хардкода
- Заменить прямые обращения к конфигурации провайдеров на использование prompt-manager API
- Обновить функцию `getContextualTranslationConfig` для получения конфигурации из prompt-manager
- Добавить поддержку редактируемых промптов через параметры функций
- Обеспечить fallback на дефолтные промпты при отсутствии пользовательских
- Добавить валидацию промптов перед использованием
- Обновить типы для поддержки промптов из prompt-manager
- Создать интеграционные тесты для проверки работы с prompt-manager
- Обновить документацию с описанием интеграции

**Ожидаемый результат:** Полностью интегрированный `contextual-translation.ts` с системой prompt-manager с поддержкой редактируемых промптов.

## Этап 4: Оптимизация chunk-text-manager.ts

### 4.1 Оптимизация операций с текстовыми фрагментами

**Цель:** Оптимизировать операции в `chunk-text-manager.ts` для улучшения производительности и упрощения кода.

**Задачи:**
- Модифицировать файл `react-app/src/shared/lib/utils/chunk-text-manager/chunk-text-manager.ts` для оптимизации функций
- Оптимизировать функцию `combineChunks` используя `Array.join` (уже оптимально O(n)), но улучшить обработку пустых массивов
- Оптимизировать функцию `splitCombinedText` используя `String.split` (уже оптимально O(n)), но улучшить обработку edge cases
- Оптимизировать функцию `convertArrayToRecord` используя `reduce` для O(n) вместо цикла for, улучшив читаемость
- Оптимизировать функцию `processContextualResponse` улучшив обработку лишних фрагментов через более эффективные алгоритмы
- Добавить мемоизацию для часто вызываемых функций
- Улучшить обработку edge cases включая пустые строки, null значения, невалидные данные
- Улучшить читаемость кода через более понятные имена и структуру
- Добавить JSDoc комментарии с описанием сложности операций
- Создать unit тесты для проверки производительности и корректности
- Обеспечить обратную совместимость с существующим API

**Ожидаемый результат:** Оптимизированные функции в `chunk-text-manager.ts` с улучшенной производительностью и обработкой edge cases.

### 4.2 Интеграция с prompt-manager

**Цель:** Интегрировать `chunk-text-manager.ts` с системой prompt-manager для использования редактируемых промптов вместо `createContextualPrompt`.

**Задачи:**
- Модифицировать функцию `prepareContextualTranslation` для использования prompt-manager вместо `createContextualPrompt`
- Заменить вызов `createContextualPrompt` на получение промпта через `PromptManager.getPrompt`
- Обновить логику построения промпта для использования плейсхолдеров из prompt-manager
- Добавить поддержку редактируемых промптов через параметры функции
- Обеспечить fallback на дефолтные промпты при отсутствии пользовательских
- Обновить типы для поддержки промптов из prompt-manager
- Удалить зависимость от `create-contextual-prompt` HOF (или оставить для обратной совместимости)
- Создать интеграционные тесты для проверки работы с prompt-manager
- Обновить документацию с описанием изменений
- Обеспечить обратную совместимость со старым API

**Ожидаемый результат:** Полностью интегрированный `chunk-text-manager.ts` с системой prompt-manager с поддержкой редактируемых промптов.

## Этап 5: Создание UI для управления промптами

### 5.1 Создание виджета настроек промптов (FSD)

**Цель:** Создать полнофункциональный виджет для управления промптами в соответствии с архитектурой FSD.

**Задачи:**
- Создать структуру виджета `react-app/src/widgets/prompt-settings/` с папками `ui/`, `model/`, `lib/`
- Создать файл типов `react-app/src/widgets/prompt-settings/model/types/prompt-settings-slice.ts` с интерфейсами для Redux slice включая `PromptSettingsState`, `PromptSettingsAction`, `PromptTemplateState`
- Создать файл `react-app/src/widgets/prompt-settings/model/prompt-settings-slice.ts` с Redux slice для управления состоянием промптов, actions для загрузки, обновления, сброса промптов, selectors для доступа к состоянию
- Создать файл `react-app/src/widgets/prompt-settings/lib/hooks/use-prompt-settings.ts` с хуком для работы с настройками промптов, функциями для загрузки, сохранения, валидации промптов
- Создать компонент `react-app/src/widgets/prompt-settings/ui/prompt-settings-form.tsx` для основной формы настроек промптов
- Создать компонент `react-app/src/widgets/prompt-settings/ui/prompt-editor.tsx` для редактирования промптов с поддержкой подсветки синтаксиса, валидации в реальном времени, автодополнения плейсхолдеров
- Создать компонент `react-app/src/widgets/prompt-settings/ui/prompt-template-selector.tsx` для выбора шаблона промпта по режиму работы
- Создать компонент `react-app/src/widgets/prompt-settings/ui/prompt-preview.tsx` для предпросмотра промпта с примерами данных, отображения подстановки плейсхолдеров, валидации перед сохранением
- Добавить функциональность сброса к дефолтным значениям с подтверждением действия
- Добавить функциональность экспорта/импорта промптов в JSON формате
- Интегрироваться с существующими UI компонентами проекта для консистентности дизайна
- Обеспечить адаптивность компонентов для различных размеров экрана
- Добавить анимации и переходы для улучшения пользовательского опыта
- Создать индексный файл `react-app/src/widgets/prompt-settings/index.ts` для экспорта виджета

**Ожидаемый результат:** Полнофункциональный виджет для управления промптами с поддержкой редактирования, предпросмотра, валидации и экспорта/импорта.

### 5.2 Интеграция в существующие настройки приложения

**Цель:** Интегрировать виджет настроек промптов в существующую систему настроек приложения.

**Задачи:**
- Найти существующий компонент настроек приложения (вероятно в `react-app/src/widgets/settings/`)
- Добавить новый раздел "Промпты" в интерфейс настроек
- Интегрировать компонент `PromptSettingsForm` в существующий UI настроек
- Обеспечить синхронизацию с Redux store для настроек промптов
- Реализовать сохранение промптов в localStorage через prompt-storage
- Добавить индикатор изменений при редактировании промптов
- Добавить подтверждение сохранения изменений
- Обеспечить загрузку промптов при открытии настроек
- Добавить обработку ошибок сохранения с информативными сообщениями
- Создать интеграционные тесты для проверки работы в составе настроек
- Обновить документацию с описанием новой функциональности

**Ожидаемый результат:** Полностью интегрированный виджет настроек промптов в существующую систему настроек приложения с синхронизацией состояния и сохранением в localStorage.

## Этап 6: Финальная интеграция и рефакторинг feature-provider.ts

### 6.1 Обновление feature-provider.ts с использованием новых handlers

**Цель:** Переписать `feature-provider.ts` используя все созданные handlers для упрощения структуры и улучшения поддерживаемости.

**Задачи:**
- Модифицировать файл `react-app/src/shared/lib/hooks/use-model/feature-provider.ts` для использования новых handlers
- Заменить старую реализацию `handleChat` на импорт из `chat-handlers`
- Заменить старую реализацию `handleContextualTranslation` на импорт из `translation-handlers`
- Заменить старую реализацию `handleSimpleTranslation` на импорт из `translation-handlers`
- Заменить старую реализацию `handleInstruction` на импорт из `translation-handlers`
- Упростить структуру `featureProvider` объекта до простого маппинга методов на handlers
- Удалить все старые функции обработки из файла
- Обеспечить сохранение существующего публичного API для обратной совместимости
- Добавить JSDoc комментарии с описанием новой структуры
- Создать интеграционные тесты для проверки работы всех режимов
- Убедиться что все существующие тесты проходят

**Ожидаемый результат:** Упрощенный и поддерживаемый `feature-provider.ts` с четкой структурой и разделением ответственности.

### 6.2 Удаление устаревшего кода и финальная полировка

**Цель:** Удалить устаревший код и провести финальную полировку рефакторинга.

**Задачи:**
- Удалить старую реализацию `create-contextual-prompt` HOF или оставить для обратной совместимости с пометкой deprecated
- Удалить неиспользуемые импорты из всех затронутых файлов
- Проверить отсутствие циклических зависимостей между модулями
- Обновить все импорты в проекте для использования новых handlers
- Провести рефакторинг кода для соответствия принципам SOLID
- Добавить недостающие JSDoc комментарии и документацию
- Создать финальные интеграционные тесты для всех режимов работы
- Провести code review для выявления потенциальных проблем
- Обновить документацию проекта с описанием новой архитектуры
- Создать миграционный гайд для разработчиков

**Ожидаемый результат:** Чистый и поддерживаемый код без устаревших зависимостей с полной документацией и тестами.

## План поэтапной реализации

### Этап 1: Подготовка инфраструктуры (2-3 дня)
Создание системы управления промптами с поддержкой шаблонов, плейсхолдеров и хранения, создание HOF для построения промптов, миграция существующих промптов в новую систему.

### Этап 2: Рефакторинг chat handler (2-3 дня)
Создание сервисов для обработки чата с разделением ответственности, рефакторинг `handleChat` с использованием новых сервисов, создание сервисов для других режимов работы.

### Этап 3: Оптимизация утилит (1-2 дня)
Оптимизация `contextual-translation.ts` и `chunk-text-manager.ts` с интеграцией prompt-manager.

### Этап 4: UI для управления промптами (2-3 дня)
Создание виджета настроек промптов по FSD архитектуре, интеграция в существующие настройки приложения.

### Этап 5: Финальная интеграция (1-2 дня)
Обновление `feature-provider.ts` с использованием новых handlers, удаление устаревшего кода, финальная полировка и тестирование.

## Технические детали

### Производительность (Big-O)

**Текущее состояние:**
- `handleChat`: O(n) где n - количество сообщений
- `combineChunks`: O(n) - оптимально
- `splitCombinedText`: O(n) - оптимально
- `getContextualTranslationConfig`: O(1) - оптимально

**После рефакторинга:**
- Параллельная загрузка RAG и контекста: O(max(RAG, Context)) вместо O(RAG + Context)
- Кэширование промптов: O(1) вместо O(n) для повторных запросов
- Оптимизация валидации: ранний возврат при ошибках O(1)
- Использование Map для конфигураций: O(1) вместо O(n) поиска

### SOLID принципы

**Single Responsibility Principle:**
- Каждый handler отвечает только за свой режим работы
- Валидация вынесена в отдельные функции
- Загрузка данных разделена по типам (RAG, контекст чата)
- Построение промптов отделено от обработки ответов
- Сохранение истории отделено от генерации ответов

**Open/Closed Principle:**
- Система промптов расширяема через шаблоны
- Новые режимы добавляются без изменения существующих handlers
- Prompt-manager поддерживает добавление новых типов промптов

**Liskov Substitution Principle:**
- Все handlers имеют единый интерфейс `(props: ModelRequestContext) => Promise<Result>`
- Можно заменить реализацию handler без изменения feature-provider
- Prompt builders взаимозаменяемы через единый интерфейс

**Interface Segregation Principle:**
- Типы разделены по функциональности (chat, translation, instruction)
- Нет "толстых" интерфейсов с избыточными методами
- Каждый handler использует только необходимые типы

**Dependency Inversion Principle:**
- Зависимости через интерфейсы и абстракции
- Prompt-manager абстрагирует хранение промптов
- Handlers зависят от абстракций, а не конкретных реализаций
- Легко мокировать для тестирования

### FSD архитектура

**Слои:**
- `shared/lib/utils` - утилиты и хелперы (prompt-manager, chat-handlers, translation-handlers)
- `shared/lib/hofs` - функции высшего порядка (create-prompt-builder)
- `widgets/prompt-settings` - виджет для управления промптами

**Правила:**
- Нет циклических зависимостей между модулями
- Импорты только из нижележащих слоев
- Типы в отдельных файлах для переиспользования
- Публичные API через индексные файлы

## Возможные проблемы и решения

### Проблема: Регрессии в существующей функциональности
**Решение:** Поэтапная миграция с сохранением старого кода до полного тестирования, создание интеграционных тестов для всех режимов работы, постепенное переключение на новую реализацию с возможностью отката.

### Проблема: Производительность при загрузке промптов
**Решение:** Кэширование промптов в памяти через prompt-manager, ленивая загрузка промптов только при необходимости, оптимизация операций чтения из localStorage, использование мемоизации для часто вызываемых функций.

### Проблема: Сложность миграции существующих промптов
**Решение:** Автоматическая миграция при первом запуске через функцию `migratePrompts`, fallback на дефолтные значения при ошибках миграции, валидация мигрированных промптов на корректность структуры, логирование процесса миграции для отладки.

### Проблема: Производительность параллельной загрузки RAG и контекста
**Решение:** Использование `Promise.all` для параллельной загрузки, обработка ошибок каждого промиса независимо, таймауты для предотвращения зависаний, кэширование загруженных контекстов.

### Проблема: Сложность тестирования handlers
**Решение:** Создание моков для всех зависимостей (IPC API, prompt-manager), unit тесты для каждого handler изолированно, интеграционные тесты для полного потока обработки, использование dependency injection для упрощения тестирования.

## Заключение

Данный план обеспечивает поэтапную реализацию рефакторинга Feature Provider с учетом существующей архитектуры проекта Underlator. Архитектура построена на принципах SOLID и FSD, что обеспечивает поддерживаемость, тестируемость и расширяемость кода.

Ключевые преимущества реализации:
- Соблюдение принципов SOLID, особенно Single Responsibility Principle
- Оптимизация производительности с учетом big-O notation
- Поддержка редактируемых системных промптов через UI
- Улучшенная поддерживаемость и тестируемость кода
- Соответствие архитектуре Feature-Sliced Design
- Использование функционального программирования для React (front-end)
- Полная типизация для обеспечения надежности кода
- Единообразная структура handlers для всех режимов работы
- Расширяемость системы для добавления новых режимов
- Готовность к будущим улучшениям и оптимизациям
